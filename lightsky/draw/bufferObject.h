/* 
 * File:   bufferObject.h
 * Author: Miles Lacey
 *
 * Created on March 31, 2014, 8:00 PM
 */

#ifndef __LS_DRAW_BUFFER_OBJECT_H__
#define	__LS_DRAW_BUFFER_OBJECT_H__

#include <GL/glew.h>

#include "lightsky/draw/setup.h"

namespace ls {
namespace draw {

/*-----------------------------------------------------------------------------
    Enumerations
-----------------------------------------------------------------------------*/
/**
 * This enumeration outlines the basic types of buffers are available for use
 * in a render context. It will be updated as more features are written.
 */
enum buffer_t : GLenum {
    LS_ARRAY_BUFFER                 = GL_ARRAY_BUFFER,
    LS_ELEMENT_BUFFER               = GL_ELEMENT_ARRAY_BUFFER,
    LS_TEXTURE_BUFFER               = GL_TEXTURE_BUFFER,
    LS_TRANSFORM_FEEDBACK_BUFFER    = GL_TRANSFORM_FEEDBACK_BUFFER,
    LS_UNIFORM_BUFFER               = GL_UNIFORM_BUFFER
};

/**
 * Different usage parameters that determine how a buffer may be used.
 */
enum buffer_usage_t : GLenum {
    LS_STATIC_READ  = GL_STATIC_READ,
    LS_STATIC_DRAW  = GL_STATIC_DRAW,
    LS_STATIC_COPY  = GL_STATIC_COPY,
    
    LS_STREAM_READ  = GL_STREAM_READ,
    LS_STREAM_DRAW  = GL_STREAM_DRAW,
    LS_STREAM_COPY  = GL_STREAM_COPY,
    
    LS_DYNAMIC_READ = GL_DYNAMIC_READ,
    LS_DYNAMIC_DRAW = GL_DYNAMIC_DRAW,
    LS_DYNAMIC_COPY = GL_DYNAMIC_COPY
};

/**
 * Memory mapping bit flags used for DMA transfers between CPU and GPU memory.
 */
enum buffer_access_t : GLbitfield {
    LS_MAP_READ_BIT                 = GL_MAP_READ_BIT,
    LS_MAP_WRITE_BIT                = GL_MAP_WRITE_BIT,
    LS_MAP_INVALIDATE_RANGE_BIT     = GL_MAP_INVALIDATE_RANGE_BIT,
    LS_MAP_INVALIDATE_BUFFER_BIT    = GL_MAP_INVALIDATE_BUFFER_BIT,
    LS_MAP_FLUSH_EXPLICIT_BIT       = GL_MAP_FLUSH_EXPLICIT_BIT,
    LS_MAP_UNSYNCHRONIZED_BIT       = GL_MAP_UNSYNCHRONIZED_BIT,
    LS_MAP_PERSISTENT_BIT           = GL_MAP_PERSISTENT_BIT,
    LS_MAP_COHERENT_BIT             = GL_MAP_COHERENT_BIT
};

/*-----------------------------------------------------------------------------
    Classes
-----------------------------------------------------------------------------*/
/**
 * @brief Vertex Buffer Object
 * 
 * This object provides RAII to an OpenGL vertex Buffer Object. Different VBO
 * types can be generated by modifying the template parameter.
 */
template <buffer_t bufferType>
class bufferObject {
    private:
        /**
         * A handle to the vertex buffer object residing on the GPU.
         */
        GLuint vbo = 0;
        
    public:
        /**
         * @brief Constructor.
         */
        bufferObject();
        
        /**
         * Copy Constructor - DELETED
         */
        bufferObject(const bufferObject&) = delete;
        
        /**
         * @brief Move Constructor
         * 
         * This moves the data contained within the constructor parameter into
         * *this. No copies are performed.
         * 
         * @param vb
         * A vertex buffer object whose data will be moved into *this.
         */
        bufferObject(bufferObject&& vb);
        
        /**
         * @brief Destructor
         * 
         * Releases all resources used by *this.
         */
        ~bufferObject();
        
        /**
         * Copy Operator - DELETED
         */
        bufferObject& operator=(const bufferObject&) = delete;
        
        /**
         * @brief Move Operator
         * 
         * This moves the data contained within the method parameter into *this.
         * No copies are performed.
         * 
         * @param vb
         * A vertex buffer object whose data will be moved into *this.
         */
        bufferObject& operator=(bufferObject&& vb);
        
        /**
         * @brief Buffer initialization.
         * 
         * Generates a vertex buffer object on the GPY that will be used to
         * contain a large pool of data.
         * 
         * @return true if the buffer was successfully created, false if not.
         */
        bool init();
        
        /**
         * Terminate the vertex buffer and release all of its resources back to
         * the GPU.
         */
        void terminate();
        
        /**
         * Get the GPU-assigned handle of this buffer object
         * @return An unsigned integer, representing the GPU-side buffer that
         * this object represents.
         */
        unsigned getId() const;
        
        /**
         * Determine if there is data used by this object
         * 
         * @returns true if this object has data residing on GPU memory, false
         * if not.
         */
        bool isValid() const;
        
        /**
         * Bind this vertex buffer to the current global rendering context.
         */
        void bind() const;
        
        /**
         * Unbind this vertex buffer object from the current render context.
         */
        void unbind() const;
        
        /**
         * Set the data within the buffer to whatever is set at "pData."
         * 
         * @param size
         * The size, in bytes, of the data that the buffer should contain.
         * 
         * @param pData
         * A pointer to the data contained within the buffer. This argument can
         * be NULL to indicate that an empty buffer should be allocated and
         * will have its contents filled later.
         * 
         * @param usage
         * The usage of this buffer. This can indicate that the buffer is
         * static, should be used to stream data occasionally, or the data is
         * dynamic and will be updated on a regular basis.
         * 
         */
        void setData(ptrdiff_t size, const void* pData, buffer_usage_t usage);
        
        /**
         * Modify the data within a buffer to contain whatever is in "pData."
         * at an offset of a specified amount of bytes.
         * 
         * @param size
         * The size, in bytes, of the data that the buffer should contain.
         * 
         * @param offset
         * The offset, in bytes, to where the data should be placed in *this.
         * 
         * @param pData
         * A pointer to the data contained within the buffer.
         * 
         */
        void setSubData(ptrdiff_t offset, ptrdiff_t size, const void* pData);
        
        /**
         * Map the contents of the buffer into memory in order to perform a DMA
         * transfer of data to the GPU.
         * 
         * @param offset
         * The offset, in bytes, to where the data should be placed in *this.
         * 
         * @param range
         * The range of bytes that will be mapped to memory.
         * 
         * @param access
         * Specifies a combination of access flags indicating the desired
         * access to the range of memory.
         * 
         * @returns void*
         * A pointer to the location in memory where the data will be mapped.
         * A NULL pointer may be returned, indicating an error that may have
         * occurred while attempting to map the buffer to memory.
         * 
         */
        void* mapData(ptrdiff_t offset, ptrdiff_t range, buffer_access_t access);
        
        /**
         * Notify the GPU that all data has been uploaded to the requested
         * location in memory and that the DMA transfer can now be performed.
         */
        bool unmapData();
};

/*-----------------------------------------------------------------------------
    External template types
-----------------------------------------------------------------------------*/
LS_DECLARE_CLASS_TYPE(vertexBuffer, bufferObject, LS_ARRAY_BUFFER);
LS_DECLARE_CLASS_TYPE(indexBuffer,  bufferObject, LS_ELEMENT_BUFFER);
LS_DECLARE_CLASS_TYPE(uvBuffer,     bufferObject, LS_ARRAY_BUFFER);
LS_DECLARE_CLASS_TYPE(colorBuffer,  bufferObject, LS_ARRAY_BUFFER);

} // end draw namespace
} // end ls namespace

#include "lightsky/draw/generic/bufferObject_impl.h"

#endif	/* __LS_DRAW_BUFFER_OBJECT_H__ */
