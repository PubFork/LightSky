<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>LightSky: ls::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LightSky
   &#160;<span id="projectnumber">Pre-Alpha</span>
   </div>
   <div id="projectbrief">A game development framework using OpenGL 3.3 and SDL.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacels_1_1utils.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ls::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacels_1_1utils_1_1utils_impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils_1_1utils_impl.html">utilsImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structls_1_1utils_1_1bit_mask.html" title="bitMask Convenience structure to facilitate bit acquisition of bytes. ">bitMask</a> Convenience structure to facilitate bit acquisition of bytes.  <a href="structls_1_1utils_1_1bit_mask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classls_1_1utils_1_1b_tree.html">bTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">B-Tree A simple tree container that allows for fast lookup of data.  <a href="classls_1_1utils_1_1b_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classls_1_1utils_1_1b_tree_node.html">bTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BTree Node A node type used by the BTree class in order to store data.  <a href="classls_1_1utils_1_1b_tree_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classls_1_1utils_1_1data_resource.html">dataResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic memory object/file abstraction.  <a href="classls_1_1utils_1_1data_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classls_1_1utils_1_1random_num.html">randomNum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo-randomn number generator using the WELLRNC 512 algorithm.  <a href="classls_1_1utils_1_1random_num.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classls_1_1utils_1_1resource.html">resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic file/resource abstraction.  <a href="classls_1_1utils_1_1resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classls_1_1utils_1_1tuple__t.html">tuple_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple Class An tuple is a set of objects determined at compile-time. These objects are constructed within a tightly packed buffer. It is recommended to construct an tuple using the "new" operator if there are many objects.  <a href="classls_1_1utils_1_1tuple__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a53ed44f6f1c3753ed11e1241ac36647b"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a></td></tr>
<tr class="memdesc:a53ed44f6f1c3753ed11e1241ac36647b"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash_t An integral type that's long enough to hold a simple hash value.  <a href="#a53ed44f6f1c3753ed11e1241ac36647b">More...</a><br /></td></tr>
<tr class="separator:a53ed44f6f1c3753ed11e1241ac36647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab58f69ca87e14d6f1fe011059fea4e5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5d">error_t</a> : int { <a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5daed035339a0dc42ab48c7957121be2187">ALERT</a>, 
<a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5dafbf56df0734baf50a74706281cdc2c76">WARNING</a>, 
<a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5da5a34fafdd6319ebdf947e3def429847f">ERROR</a>
 }</td></tr>
<tr class="memdesc:ab58f69ca87e14d6f1fe011059fea4e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">error_t A basic enumeration for lightsky assertions.  <a href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5d">More...</a><br /></td></tr>
<tr class="separator:ab58f69ca87e14d6f1fe011059fea4e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b60097c422c6b68c6bc3f2e3e37dad0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a9b60097c422c6b68c6bc3f2e3e37dad0">bnode_dir_t</a> : unsigned { <a class="el" href="namespacels_1_1utils.html#a9b60097c422c6b68c6bc3f2e3e37dad0a6166f2e07f0785161cc16a1b240e3dc3">BNODE_LEFT</a> = 0, 
<a class="el" href="namespacels_1_1utils.html#a9b60097c422c6b68c6bc3f2e3e37dad0a87b5bed5beb60e9f902ab3b8cd2e14f3">BNODE_RIGHT</a> = 1, 
<a class="el" href="namespacels_1_1utils.html#a9b60097c422c6b68c6bc3f2e3e37dad0a31a777f60dd4a8908d43975080f1c5b1">BNODE_MAX</a>
 }</td></tr>
<tr class="memdesc:a9b60097c422c6b68c6bc3f2e3e37dad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">bnode_dir_t A simple enumeration to help determine where within a btree-node a child node should be placed.  <a href="namespacels_1_1utils.html#a9b60097c422c6b68c6bc3f2e3e37dad0">More...</a><br /></td></tr>
<tr class="separator:a9b60097c422c6b68c6bc3f2e3e37dad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f2dd4d3b29d671977ccf97c4ad681c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a46f2dd4d3b29d671977ccf97c4ad681c">endian_t</a> : uint32_t { <a class="el" href="namespacels_1_1utils.html#a46f2dd4d3b29d671977ccf97c4ad681ca0c096dca1a0eaa414800d03be90aa14f">LS_LITTLE_ENDIAN</a> = 0x00000001, 
<a class="el" href="namespacels_1_1utils.html#a46f2dd4d3b29d671977ccf97c4ad681caa2a4e0f8cb7e8973c91715cc562d9c51">LS_BIG_ENDIAN</a> = 0x01000000, 
<a class="el" href="namespacels_1_1utils.html#a46f2dd4d3b29d671977ccf97c4ad681cab3cdd7e3bf4d96afcfb6185a465f5246">LS_PDP_ENDIAN</a> = 0x00010000, 
<a class="el" href="namespacels_1_1utils.html#a46f2dd4d3b29d671977ccf97c4ad681cae3f5e5798cae0f1e0d34ae2a65379e6e">LS_UNKNOWN_ENDIAN</a> = 0xFFFFFFFF
 }</td></tr>
<tr class="separator:a46f2dd4d3b29d671977ccf97c4ad681c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96afe13b74e009eebc1836063167d358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a96afe13b74e009eebc1836063167d358">runtime_assert</a> (bool condition, <a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5d">error_t</a> type, const char *const msg)</td></tr>
<tr class="memdesc:a96afe13b74e009eebc1836063167d358"><td class="mdescLeft">&#160;</td><td class="mdescRight">runtime_assert Throw an <a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5d" title="error_t A basic enumeration for lightsky assertions. ">ls::utils::error_t</a> and/or send a message to stdout/stderr.  <a href="#a96afe13b74e009eebc1836063167d358">More...</a><br /></td></tr>
<tr class="separator:a96afe13b74e009eebc1836063167d358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce0bd3f2d5ca1ac7ec533eade48f01c"><td class="memTemplParams" colspan="2">template&lt;typename key_t &gt; </td></tr>
<tr class="memitem:a3ce0bd3f2d5ca1ac7ec533eade48f01c"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a3ce0bd3f2d5ca1ac7ec533eade48f01c">getByte</a> (const key_t *key, unsigned iter)</td></tr>
<tr class="memdesc:a3ce0bd3f2d5ca1ac7ec533eade48f01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">getByte Retrieve the Nth byte of a basic data type.  <a href="#a3ce0bd3f2d5ca1ac7ec533eade48f01c">More...</a><br /></td></tr>
<tr class="separator:a3ce0bd3f2d5ca1ac7ec533eade48f01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc863c38817c3c7fd5c570faf74df17"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7cc863c38817c3c7fd5c570faf74df17"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a7cc863c38817c3c7fd5c570faf74df17">getByte</a> (const char *key, unsigned iter)</td></tr>
<tr class="memdesc:a7cc863c38817c3c7fd5c570faf74df17"><td class="mdescLeft">&#160;</td><td class="mdescRight">getByte (char string specialization) Retrieve the Nth byte of a basic data type.  <a href="#a7cc863c38817c3c7fd5c570faf74df17">More...</a><br /></td></tr>
<tr class="separator:a7cc863c38817c3c7fd5c570faf74df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3508cbe35e975ee8d7f92b746a460f76"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3508cbe35e975ee8d7f92b746a460f76"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a3508cbe35e975ee8d7f92b746a460f76">getByte</a> (const wchar_t *key, unsigned iter)</td></tr>
<tr class="memdesc:a3508cbe35e975ee8d7f92b746a460f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">getByte (wchar_t string specialization) Retrieve the Nth byte of a basic data type.  <a href="#a3508cbe35e975ee8d7f92b746a460f76">More...</a><br /></td></tr>
<tr class="separator:a3508cbe35e975ee8d7f92b746a460f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24389d899aa53d209e2b226b25d6a60"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac24389d899aa53d209e2b226b25d6a60"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#ac24389d899aa53d209e2b226b25d6a60">getByte</a> (const char16_t *key, unsigned iter)</td></tr>
<tr class="memdesc:ac24389d899aa53d209e2b226b25d6a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">getByte (char16_t string specialization) Retrieve the Nth byte of a basic data type.  <a href="#ac24389d899aa53d209e2b226b25d6a60">More...</a><br /></td></tr>
<tr class="separator:ac24389d899aa53d209e2b226b25d6a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959abd2644bc4d3ff8ee7513ad6e7a16"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a959abd2644bc4d3ff8ee7513ad6e7a16"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a959abd2644bc4d3ff8ee7513ad6e7a16">getByte</a> (const char32_t *key, unsigned iter)</td></tr>
<tr class="memdesc:a959abd2644bc4d3ff8ee7513ad6e7a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">getByte (char32_t string specialization) Retrieve the Nth byte of a basic data type.  <a href="#a959abd2644bc4d3ff8ee7513ad6e7a16">More...</a><br /></td></tr>
<tr class="separator:a959abd2644bc4d3ff8ee7513ad6e7a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba751679836c0520f988a06851d02fd"><td class="memItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#adba751679836c0520f988a06851d02fd">getArgByteSize</a> (unsigned size)</td></tr>
<tr class="memdesc:adba751679836c0520f988a06851d02fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">getArgByteSize Helper function to sum the number of bytes used by a set of types.  <a href="#adba751679836c0520f988a06851d02fd">More...</a><br /></td></tr>
<tr class="separator:adba751679836c0520f988a06851d02fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec59137bf38e7f9ddc058f6cc757046"><td class="memTemplParams" colspan="2">template&lt;typename... integral_t&gt; </td></tr>
<tr class="memitem:a6ec59137bf38e7f9ddc058f6cc757046"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a6ec59137bf38e7f9ddc058f6cc757046">getArgByteSize</a> (unsigned size, integral_t...sizeN)</td></tr>
<tr class="memdesc:a6ec59137bf38e7f9ddc058f6cc757046"><td class="mdescLeft">&#160;</td><td class="mdescRight">getArgByteSize Helper function to sum the number of bytes used by a set of types.  <a href="#a6ec59137bf38e7f9ddc058f6cc757046">More...</a><br /></td></tr>
<tr class="separator:a6ec59137bf38e7f9ddc058f6cc757046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41f7aff32bda8a1c09987b49e9fff57"><td class="memTemplParams" colspan="2">template&lt;typename... integral_t&gt; </td></tr>
<tr class="memitem:ae41f7aff32bda8a1c09987b49e9fff57"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#ae41f7aff32bda8a1c09987b49e9fff57">getByteSize</a> ()</td></tr>
<tr class="memdesc:ae41f7aff32bda8a1c09987b49e9fff57"><td class="mdescLeft">&#160;</td><td class="mdescRight">getByteSize Sum the number of bytes used by a set of types.  <a href="#ae41f7aff32bda8a1c09987b49e9fff57">More...</a><br /></td></tr>
<tr class="separator:ae41f7aff32bda8a1c09987b49e9fff57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee791167ca041966fc9162b85fecf917"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a46f2dd4d3b29d671977ccf97c4ad681c">endian_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#aee791167ca041966fc9162b85fecf917">getEndianOrder</a> ()</td></tr>
<tr class="separator:aee791167ca041966fc9162b85fecf917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff29c0be67deb66b6538607129367028"><td class="memItemLeft" align="right" valign="top">constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#aff29c0be67deb66b6538607129367028">btol</a> (uint16_t n)</td></tr>
<tr class="separator:aff29c0be67deb66b6538607129367028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0695c04ff154c015e5f5259ded36b00"><td class="memItemLeft" align="right" valign="top">constexpr int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#ab0695c04ff154c015e5f5259ded36b00">btol</a> (int16_t n)</td></tr>
<tr class="separator:ab0695c04ff154c015e5f5259ded36b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea33b0755486b2efef9f66403b1ac57"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#abea33b0755486b2efef9f66403b1ac57">btol</a> (uint32_t n)</td></tr>
<tr class="separator:abea33b0755486b2efef9f66403b1ac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2cd4eda56bcd75bcc586bd2cb99324"><td class="memItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#acc2cd4eda56bcd75bcc586bd2cb99324">btol</a> (int32_t n)</td></tr>
<tr class="separator:acc2cd4eda56bcd75bcc586bd2cb99324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3ea0bf2b99f0c1d9d1fa8b34329107"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a4d3ea0bf2b99f0c1d9d1fa8b34329107">btol</a> (uint64_t n)</td></tr>
<tr class="separator:a4d3ea0bf2b99f0c1d9d1fa8b34329107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3d0523d666351728a104ff7822c374"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a0a3d0523d666351728a104ff7822c374">btol</a> (int64_t n)</td></tr>
<tr class="separator:a0a3d0523d666351728a104ff7822c374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2af0a3948a7e9c5cda4083409ac041"><td class="memTemplParams" colspan="2">template&lt;typename num_t &gt; </td></tr>
<tr class="memitem:abd2af0a3948a7e9c5cda4083409ac041"><td class="memTemplItemLeft" align="right" valign="top">num_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#abd2af0a3948a7e9c5cda4083409ac041">btol</a> (num_t n)</td></tr>
<tr class="separator:abd2af0a3948a7e9c5cda4083409ac041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6eea42180965606079e486faad2c37c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#ad6eea42180965606079e486faad2c37c">hashDJB2_impl</a> (const char *str, unsigned int hashVal)</td></tr>
<tr class="separator:ad6eea42180965606079e486faad2c37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1a3c504bb9cb6acd0ad54da5ea4f19"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#abc1a3c504bb9cb6acd0ad54da5ea4f19">hashDJB2</a> (const char *str)</td></tr>
<tr class="memdesc:abc1a3c504bb9cb6acd0ad54da5ea4f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">DJB2 Hashing Function This hash algorithm was found on here: <a href="http://nguillemot.blogspot.com/2012/06/side-story-compile-time-string-hashing.html">http://nguillemot.blogspot.com/2012/06/side-story-compile-time-string-hashing.html</a>.  <a href="#abc1a3c504bb9cb6acd0ad54da5ea4f19">More...</a><br /></td></tr>
<tr class="separator:abc1a3c504bb9cb6acd0ad54da5ea4f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3438626c6afc738773ac3e60a9ca3f1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#aa3438626c6afc738773ac3e60a9ca3f1">hashSDBM_impl</a> (const char *str, unsigned int hashVal)</td></tr>
<tr class="separator:aa3438626c6afc738773ac3e60a9ca3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da43b7cb7175cf10efacd1d443e6fea"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a3da43b7cb7175cf10efacd1d443e6fea">hashSDBM</a> (const char *str)</td></tr>
<tr class="memdesc:a3da43b7cb7175cf10efacd1d443e6fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDBM Hashing Function This hash algorithm was found here: <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="#a3da43b7cb7175cf10efacd1d443e6fea">More...</a><br /></td></tr>
<tr class="separator:a3da43b7cb7175cf10efacd1d443e6fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6c0184be611eeb9f01313fe9054b95"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#acd6c0184be611eeb9f01313fe9054b95">hashFNV1_impl</a> (const char *str, unsigned int hashVal)</td></tr>
<tr class="separator:acd6c0184be611eeb9f01313fe9054b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df29a51c8e8cc8a3992aed21c759a1b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a6df29a51c8e8cc8a3992aed21c759a1b">hashFNV1</a> (const char *str)</td></tr>
<tr class="memdesc:a6df29a51c8e8cc8a3992aed21c759a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">FNV-1a Hashing Function This hash algorithm was found here: <a href="http://www.eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx">http://www.eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx</a>.  <a href="#a6df29a51c8e8cc8a3992aed21c759a1b">More...</a><br /></td></tr>
<tr class="separator:a6df29a51c8e8cc8a3992aed21c759a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaaec6f662c311ff093845319cb577a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#aedaaec6f662c311ff093845319cb577a">crc32</a> (const char *str, <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> prevCrc)</td></tr>
<tr class="separator:aedaaec6f662c311ff093845319cb577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635789a068e5357de1d9b40be0e52155"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a635789a068e5357de1d9b40be0e52155"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a635789a068e5357de1d9b40be0e52155">logMsg</a> (const Arg &amp;arg)</td></tr>
<tr class="separator:a635789a068e5357de1d9b40be0e52155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8db48f9a89d47fe0d7582b1bcc61717"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename... Args&gt; </td></tr>
<tr class="memitem:aa8db48f9a89d47fe0d7582b1bcc61717"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#aa8db48f9a89d47fe0d7582b1bcc61717">logMsg</a> (const Arg &amp;arg, const Args &amp;...args)</td></tr>
<tr class="separator:aa8db48f9a89d47fe0d7582b1bcc61717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630b424ab0d4f73b61d941da425daafd"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a630b424ab0d4f73b61d941da425daafd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a630b424ab0d4f73b61d941da425daafd">logErr</a> (const Arg &amp;arg)</td></tr>
<tr class="separator:a630b424ab0d4f73b61d941da425daafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a64949c47e69bc4752bacd46507a20"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename... Args&gt; </td></tr>
<tr class="memitem:a41a64949c47e69bc4752bacd46507a20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a41a64949c47e69bc4752bacd46507a20">logErr</a> (const Arg &amp;arg, const Args &amp;...args)</td></tr>
<tr class="separator:a41a64949c47e69bc4752bacd46507a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d501646d4c9b408975e5b1474d8e23d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a6d501646d4c9b408975e5b1474d8e23d">hashCRC32</a> (const char *str, <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> prevCrc=0xFFFFFFFF)</td></tr>
<tr class="memdesc:a6d501646d4c9b408975e5b1474d8e23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC32 Hashing function A simple compile-time hashing function using the CRC32 algorithm.  <a href="#a6d501646d4c9b408975e5b1474d8e23d">More...</a><br /></td></tr>
<tr class="separator:a6d501646d4c9b408975e5b1474d8e23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94b016e538c180a70a03e7dd3215fcc"><td class="memTemplParams" colspan="2">template&lt;typename arg_t &gt; </td></tr>
<tr class="memitem:aa94b016e538c180a70a03e7dd3215fcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#aa94b016e538c180a70a03e7dd3215fcc">logMsg</a> (const arg_t &amp;arg)</td></tr>
<tr class="memdesc:aa94b016e538c180a70a03e7dd3215fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print multiple parameters to std::cout.  <a href="#aa94b016e538c180a70a03e7dd3215fcc">More...</a><br /></td></tr>
<tr class="separator:aa94b016e538c180a70a03e7dd3215fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc22402c4f2c039ba72039fbd07ec4d"><td class="memTemplParams" colspan="2">template&lt;typename arg_t , typename... args_t&gt; </td></tr>
<tr class="memitem:a0bc22402c4f2c039ba72039fbd07ec4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a0bc22402c4f2c039ba72039fbd07ec4d">logMsg</a> (const arg_t &amp;arg, const args_t &amp;...args)</td></tr>
<tr class="memdesc:a0bc22402c4f2c039ba72039fbd07ec4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print multiple parameters to std::cout.  <a href="#a0bc22402c4f2c039ba72039fbd07ec4d">More...</a><br /></td></tr>
<tr class="separator:a0bc22402c4f2c039ba72039fbd07ec4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05153ef5d3bea7b710081456763dac8"><td class="memTemplParams" colspan="2">template&lt;typename arg_t &gt; </td></tr>
<tr class="memitem:af05153ef5d3bea7b710081456763dac8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#af05153ef5d3bea7b710081456763dac8">logErr</a> (const arg_t &amp;arg)</td></tr>
<tr class="memdesc:af05153ef5d3bea7b710081456763dac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print multiple parameters to std::cerr.  <a href="#af05153ef5d3bea7b710081456763dac8">More...</a><br /></td></tr>
<tr class="separator:af05153ef5d3bea7b710081456763dac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb49dc84b286b4ca2164c39520d9333"><td class="memTemplParams" colspan="2">template&lt;typename arg_t , typename... args_t&gt; </td></tr>
<tr class="memitem:a7bb49dc84b286b4ca2164c39520d9333"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#a7bb49dc84b286b4ca2164c39520d9333">logErr</a> (const arg_t &amp;arg, const args_t &amp;...args)</td></tr>
<tr class="memdesc:a7bb49dc84b286b4ca2164c39520d9333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print multiple parameters to std::cerr.  <a href="#a7bb49dc84b286b4ca2164c39520d9333">More...</a><br /></td></tr>
<tr class="separator:a7bb49dc84b286b4ca2164c39520d9333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41c68ce29e18c803a3e583dda24f6d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af41c68ce29e18c803a3e583dda24f6d0"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#af41c68ce29e18c803a3e583dda24f6d0">toString</a> (const T &amp;data)</td></tr>
<tr class="memdesc:af41c68ce29e18c803a3e583dda24f6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a basic data type to an std::string.  <a href="#af41c68ce29e18c803a3e583dda24f6d0">More...</a><br /></td></tr>
<tr class="separator:af41c68ce29e18c803a3e583dda24f6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a4bbcb42ad7eeab7233a7464d4d45e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacels_1_1utils.html#aa7a4bbcb42ad7eeab7233a7464d4d45e">convertWtoMb</a> (const std::wstring &amp;wstr)</td></tr>
<tr class="memdesc:aa7a4bbcb42ad7eeab7233a7464d4d45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Wide String to a Multi-Byte Character String.  <a href="#aa7a4bbcb42ad7eeab7233a7464d4d45e">More...</a><br /></td></tr>
<tr class="separator:aa7a4bbcb42ad7eeab7233a7464d4d45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a53ed44f6f1c3753ed11e1241ac36647b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">ls::utils::hash_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hash_t An integral type that's long enough to hold a simple hash value. </p>

<p>Definition at line <a class="el" href="hash_8h_source.html#l00028">28</a> of file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a9b60097c422c6b68c6bc3f2e3e37dad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacels_1_1utils.html#a9b60097c422c6b68c6bc3f2e3e37dad0">ls::utils::bnode_dir_t</a> : unsigned</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bnode_dir_t A simple enumeration to help determine where within a btree-node a child node should be placed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9b60097c422c6b68c6bc3f2e3e37dad0a6166f2e07f0785161cc16a1b240e3dc3"></a>BNODE_LEFT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9b60097c422c6b68c6bc3f2e3e37dad0a87b5bed5beb60e9f902ab3b8cd2e14f3"></a>BNODE_RIGHT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9b60097c422c6b68c6bc3f2e3e37dad0a31a777f60dd4a8908d43975080f1c5b1"></a>BNODE_MAX&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00024">24</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a46f2dd4d3b29d671977ccf97c4ad681c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacels_1_1utils.html#a46f2dd4d3b29d671977ccf97c4ad681c">ls::utils::endian_t</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration can be placed into templated objects in order to generate compile-time code based on a program's target endianness.</p>
<p>The values placed in this enum are used just in case the need arises in order to manually compare them against the number order in the endianValues[] array. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a46f2dd4d3b29d671977ccf97c4ad681ca0c096dca1a0eaa414800d03be90aa14f"></a>LS_LITTLE_ENDIAN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46f2dd4d3b29d671977ccf97c4ad681caa2a4e0f8cb7e8973c91715cc562d9c51"></a>LS_BIG_ENDIAN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46f2dd4d3b29d671977ccf97c4ad681cab3cdd7e3bf4d96afcfb6185a465f5246"></a>LS_PDP_ENDIAN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46f2dd4d3b29d671977ccf97c4ad681cae3f5e5798cae0f1e0d34ae2a65379e6e"></a>LS_UNKNOWN_ENDIAN&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00026">26</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab58f69ca87e14d6f1fe011059fea4e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5d">ls::utils::error_t</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>error_t A basic enumeration for lightsky assertions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab58f69ca87e14d6f1fe011059fea4e5daed035339a0dc42ab48c7957121be2187"></a>ALERT&#160;</td><td class="fielddoc">
<p>ALERT when used with runtime_assert, this indicates that a message will print to std::cout. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab58f69ca87e14d6f1fe011059fea4e5dafbf56df0734baf50a74706281cdc2c76"></a>WARNING&#160;</td><td class="fielddoc">
<p>WARNING when used with runtime_assert, this indicates that a message will print to std::cerr. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab58f69ca87e14d6f1fe011059fea4e5da5a34fafdd6319ebdf947e3def429847f"></a>ERROR&#160;</td><td class="fielddoc">
<p>ERROR when used with runtime_assert, this indicates that a message will print to std::cerr, and an exception of type <a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5d" title="error_t A basic enumeration for lightsky assertions. ">ls::utils::error_t</a> is thrown. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="assert_8h_source.html#l00014">14</a> of file <a class="el" href="assert_8h_source.html">assert.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aff29c0be67deb66b6538607129367028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint16_t ls::utils::btol </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the bytes of an unsigned 16-bit integral type between big and little endian representation. This function can be used at compile-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an unsigned integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t The value of the input parameter with its bytes swapped between big &amp; little endian representation. </dd></dl>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00061">61</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab0695c04ff154c015e5f5259ded36b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int16_t ls::utils::btol </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the bytes of a signed 16-bit integral type between big and little endian representation. This function can be used at compile-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a signed integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int16_t The value of the input parameter with its bytes swapped between big &amp; little endian representation. </dd></dl>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00077">77</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="abea33b0755486b2efef9f66403b1ac57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t ls::utils::btol </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the bytes of an unsigned 32-bit integral type between big and little endian representation. This function can be used at compile-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an unsigned integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The value of the input parameter with its bytes swapped between big &amp; little endian representation. </dd></dl>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00093">93</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="acc2cd4eda56bcd75bcc586bd2cb99324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int32_t ls::utils::btol </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the bytes of a signed 32-bit integral type between big and little endian representation. This function can be used at compile-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a signed integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t The value of the input parameter with its bytes swapped between big &amp; little endian representation. </dd></dl>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00113">113</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d3ea0bf2b99f0c1d9d1fa8b34329107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t ls::utils::btol </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the bytes of an unsigned 64-bit integral type between big and little endian representation. This function can be used at compile-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an unsigned integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t The value of the input parameter with its bytes swapped between big &amp; little endian representation. </dd></dl>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00129">129</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0a3d0523d666351728a104ff7822c374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t ls::utils::btol </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the bytes of a signed 64-bit integral type between big and little endian representation. This function can be used at compile-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a signed integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int64_t The value of the input parameter with its bytes swapped between big &amp; little endian representation. </dd></dl>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00153">153</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd2af0a3948a7e9c5cda4083409ac041"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename num_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">num_t ls::utils::btol </td>
          <td>(</td>
          <td class="paramtype">num_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the bytes of a POD type between big and little endian representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A plain-old-data type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>num_t The value of the input parameter with its bytes swapped between big &amp; little endian representation. </dd></dl>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00168">168</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa7a4bbcb42ad7eeab7233a7464d4d45e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ls::utils::convertWtoMb </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a Wide String to a Multi-Byte Character String. </p>
<p>This function assists in making an application cope with UTF-8 and UTF-16 compatibility issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstr</td><td>A wide-character string object which needs to be converted into a multi-byte string representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string A std::string object that uses 'char' types instead of the input parameter's 'wchar_t' type. </dd></dl>

<p>Definition at line <a class="el" href="string__utils_8cpp_source.html#l00019">19</a> of file <a class="el" href="string__utils_8cpp_source.html">string_utils.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedaaec6f662c311ff093845319cb577a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> ls::utils::crc32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_t&#160;</td>
          <td class="paramname"><em>prevCrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hash__impl_8h_source.html#l00126">126</a> of file <a class="el" href="hash__impl_8h_source.html">hash_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="adba751679836c0520f988a06851d02fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned ls::utils::getArgByteSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getArgByteSize Helper function to sum the number of bytes used by a set of types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>An unsigned integer representing the size, in bytes, of an object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned integer, representing the size, in bytes, of an object. This can be the size of a built-in type, or user-defined structures. </dd></dl>

<p>Definition at line <a class="el" href="byte_size__impl_8h_source.html#l00008">8</a> of file <a class="el" href="byte_size__impl_8h_source.html">byteSize_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6ec59137bf38e7f9ddc058f6cc757046"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... integral_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned ls::utils::getArgByteSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integral_t...&#160;</td>
          <td class="paramname"><em>sizeN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getArgByteSize Helper function to sum the number of bytes used by a set of types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>An unsigned integer representing the size, in bytes, of an object.</td></tr>
    <tr><td class="paramname">sizeN</td><td>A set of unsigned integers that contain the byte size of a set of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned integer, representing the size, in bytes, of a set of object types. These types can be built-in, or user-defined structures. </dd></dl>

<p>Definition at line <a class="el" href="byte_size__impl_8h_source.html#l00016">16</a> of file <a class="el" href="byte_size__impl_8h_source.html">byteSize_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce0bd3f2d5ca1ac7ec533eade48f01c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a>* ls::utils::getByte </td>
          <td>(</td>
          <td class="paramtype">const key_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getByte Retrieve the Nth byte of a basic data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">iter</td><td>The iterator which specifies the Nth byte in 'key'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Nth byte in 'key,' specified by 'iter.' </dd></dl>

</div>
</div>
<a class="anchor" id="a7cc863c38817c3c7fd5c570faf74df17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a>* ls::utils::getByte </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getByte (char string specialization) Retrieve the Nth byte of a basic data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">iter</td><td>The iterator which specifies the Nth byte in 'key'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Nth byte in 'key,' specified by 'iter.' </dd></dl>

</div>
</div>
<a class="anchor" id="a3508cbe35e975ee8d7f92b746a460f76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a>* ls::utils::getByte </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getByte (wchar_t string specialization) Retrieve the Nth byte of a basic data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">iter</td><td>The iterator which specifies the Nth byte in 'key'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Nth byte in 'key,' specified by 'iter.' </dd></dl>

</div>
</div>
<a class="anchor" id="ac24389d899aa53d209e2b226b25d6a60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a>* ls::utils::getByte </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getByte (char16_t string specialization) Retrieve the Nth byte of a basic data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">iter</td><td>The iterator which specifies the Nth byte in 'key'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Nth byte in 'key,' specified by 'iter.' </dd></dl>

</div>
</div>
<a class="anchor" id="a959abd2644bc4d3ff8ee7513ad6e7a16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="structls_1_1utils_1_1bit_mask.html">bitMask</a>* ls::utils::getByte </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getByte (char32_t string specialization) Retrieve the Nth byte of a basic data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">iter</td><td>The iterator which specifies the Nth byte in 'key'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Nth byte in 'key,' specified by 'iter.' </dd></dl>

</div>
</div>
<a class="anchor" id="ae41f7aff32bda8a1c09987b49e9fff57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... integral_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned ls::utils::getByteSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getByteSize Sum the number of bytes used by a set of types. </p>
<dl class="section return"><dt>Returns</dt><dd>An unsigned integer, representing the size, in bytes, of a set of object types. These types can be built-in, or user-defined structures. </dd></dl>

<p>Definition at line <a class="el" href="byte_size__impl_8h_source.html#l00024">24</a> of file <a class="el" href="byte_size__impl_8h_source.html">byteSize_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee791167ca041966fc9162b85fecf917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a46f2dd4d3b29d671977ccf97c4ad681c">endian_t</a> ls::utils::getEndianOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple function that can be used to help determine a program's endianness at compile-time. </p>

<p>Definition at line <a class="el" href="endian_8h_source.html#l00038">38</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d501646d4c9b408975e5b1474d8e23d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> ls::utils::hashCRC32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hash_t&#160;</td>
          <td class="paramname"><em>prevCrc</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRC32 Hashing function A simple compile-time hashing function using the CRC32 algorithm. </p>
<p>This method was adapted from a previous implementation on StackOverflow: <a href="http://stackoverflow.com/a/23683218/1217127">http://stackoverflow.com/a/23683218/1217127</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A c-style string that will be hashed.</td></tr>
    <tr><td class="paramname">prevCrc</td><td>A previous hash value that will be modified by the current string's hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 32-bit integer, representing a hashed value of the input string. </dd></dl>

</div>
</div>
<a class="anchor" id="abc1a3c504bb9cb6acd0ad54da5ea4f19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> ls::utils::hashDJB2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DJB2 Hashing Function This hash algorithm was found on here: <a href="http://nguillemot.blogspot.com/2012/06/side-story-compile-time-string-hashing.html">http://nguillemot.blogspot.com/2012/06/side-story-compile-time-string-hashing.html</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to a null-terminated c-style string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer-type, representing the hash value using the DJB2 algorithm. </dd></dl>

<p>Definition at line <a class="el" href="hash__impl_8h_source.html#l00019">19</a> of file <a class="el" href="hash__impl_8h_source.html">hash_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6eea42180965606079e486faad2c37c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> ls::utils::hashDJB2_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hashVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hash__impl_8h_source.html#l00009">9</a> of file <a class="el" href="hash__impl_8h_source.html">hash_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6df29a51c8e8cc8a3992aed21c759a1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> ls::utils::hashFNV1 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FNV-1a Hashing Function This hash algorithm was found here: <a href="http://www.eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx">http://www.eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to a null-terminated c-style string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer-type, representing the hash value using the FNV-1a algorithm. </dd></dl>

<p>Definition at line <a class="el" href="hash__impl_8h_source.html#l00059">59</a> of file <a class="el" href="hash__impl_8h_source.html">hash_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="acd6c0184be611eeb9f01313fe9054b95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> ls::utils::hashFNV1_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hashVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hash__impl_8h_source.html#l00049">49</a> of file <a class="el" href="hash__impl_8h_source.html">hash_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3da43b7cb7175cf10efacd1d443e6fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> ls::utils::hashSDBM </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDBM Hashing Function This hash algorithm was found here: <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to a null-terminated c-style string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer-type, representing the hash value using the SDBM algorithm. </dd></dl>

<p>Definition at line <a class="el" href="hash__impl_8h_source.html#l00039">39</a> of file <a class="el" href="hash__impl_8h_source.html">hash_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa3438626c6afc738773ac3e60a9ca3f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacels_1_1utils.html#a53ed44f6f1c3753ed11e1241ac36647b">hash_t</a> ls::utils::hashSDBM_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hashVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hash__impl_8h_source.html#l00029">29</a> of file <a class="el" href="hash__impl_8h_source.html">hash_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a630b424ab0d4f73b61d941da425daafd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::logErr </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="log__impl_8h_source.html#l00018">18</a> of file <a class="el" href="log__impl_8h_source.html">log_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a41a64949c47e69bc4752bacd46507a20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::logErr </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="log__impl_8h_source.html#l00024">24</a> of file <a class="el" href="log__impl_8h_source.html">log_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="af05153ef5d3bea7b710081456763dac8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::logErr </td>
          <td>(</td>
          <td class="paramtype">const arg_t &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print multiple parameters to std::cerr. </p>
<p>This method is syntactic sugar to write data to a standard output stream. It is similar to the printf() family of functions, however all values are separated by commas. Use of this function will cause a new line to be printed to the output stream afterwards; std::cerr.flush() will also be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A constant reference to a data type which can be send to std::cerr using the 'std::ostream::operator::&lt;&lt;()' overload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bb49dc84b286b4ca2164c39520d9333"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg_t , typename... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::logErr </td>
          <td>(</td>
          <td class="paramtype">const arg_t &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const args_t &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print multiple parameters to std::cerr. </p>
<p>This method is syntactic sugar to write data to a standard output stream. It is similar to the printf() family of functions, however all values are separated by commas. Use of this function will cause a new line to be printed to the output stream afterwards; std::cerr.flush() will also be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A constant reference to a data type which can be send to std::cerr using the 'std::ostream::operator::&lt;&lt;()' overload.</td></tr>
    <tr><td class="paramname">args</td><td>A constant reference to multiple variadic arguments that will be written to std::cerr after 'arg' is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a635789a068e5357de1d9b40be0e52155"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::logMsg </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="log__impl_8h_source.html#l00006">6</a> of file <a class="el" href="log__impl_8h_source.html">log_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8db48f9a89d47fe0d7582b1bcc61717"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::logMsg </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="log__impl_8h_source.html#l00012">12</a> of file <a class="el" href="log__impl_8h_source.html">log_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa94b016e538c180a70a03e7dd3215fcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::logMsg </td>
          <td>(</td>
          <td class="paramtype">const arg_t &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print multiple parameters to std::cout. </p>
<p>This method is syntactic sugar to write data to a standard output stream. It is similar to the printf() family of functions, however all values are separated by commas. Use of this function will cause a new line to be printed to the output stream afterwards; std::cout.flush() will also be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A constant reference to a data type which can be send to std::cout using the 'std::ostream::operator::&lt;&lt;()' overload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bc22402c4f2c039ba72039fbd07ec4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg_t , typename... args_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::logMsg </td>
          <td>(</td>
          <td class="paramtype">const arg_t &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const args_t &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print multiple parameters to std::cout. </p>
<p>This method is syntactic sugar to write data to a standard output stream. It is similar to the printf() family of functions, however all values are separated by commas. Use of this function will cause a new line to be printed to the output stream afterwards; std::cout.flush() will also be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A constant reference to a data type which can be send to std::cout using the 'std::ostream::operator::&lt;&lt;()' overload.</td></tr>
    <tr><td class="paramname">args</td><td>A constant reference to multiple variadic arguments that will be written to std::cout after 'arg' is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96afe13b74e009eebc1836063167d358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ls::utils::runtime_assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">error_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runtime_assert Throw an <a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5d" title="error_t A basic enumeration for lightsky assertions. ">ls::utils::error_t</a> and/or send a message to stdout/stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>The boolean check to determine if an assertion should be raised. If the condition tests TRUE, then no assertion is made, otherwise an exception could be raised (of type <a class="el" href="namespacels_1_1utils.html#ab58f69ca87e14d6f1fe011059fea4e5d" title="error_t A basic enumeration for lightsky assertions. ">ls::utils::error_t</a>), a message could be printed to stdout, or an error will be sent to stderr.</td></tr>
    <tr><td class="paramname">type</td><td>An error type that indicates if an assertion is a simple alert message, a warning, or a critical error.</td></tr>
    <tr><td class="paramname">msg</td><td>The message that will be printed to an standard output stream if the condition tests FALSE. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assert_8cpp_source.html#l00008">8</a> of file <a class="el" href="assert_8cpp_source.html">assert.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af41c68ce29e18c803a3e583dda24f6d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string ls::utils::toString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a basic data type to an std::string. </p>
<p>This function is only here because not all C++11-supporting versions of GCC have std::to_string().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>A generic type that can be printed to an std::ostream using the '&lt;&lt;' operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string A string-representation of the input parameter </dd></dl>

<p>Definition at line <a class="el" href="string__utils__impl_8h_source.html#l00008">8</a> of file <a class="el" href="string__utils__impl_8h_source.html">string_utils_impl.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacels.html">ls</a></li><li class="navelem"><a class="el" href="namespacels_1_1utils.html">utils</a></li>
    <li class="footer">Generated on Sun Oct 26 2014 21:21:41 for LightSky by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
