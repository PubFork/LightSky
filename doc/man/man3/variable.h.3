.TH "C:/Users/miles/C++/projects/LightSky/lightsky/script/variable.h" 3 "Sun Oct 26 2014" "Version Pre-Alpha" "LightSky" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/miles/C++/projects/LightSky/lightsky/script/variable.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <string>\fP
.br
\fC#include <iostream>\fP
.br
\fC#include 'lightsky/script/setup\&.h'\fP
.br
\fC#include 'lightsky/script/scriptable\&.h'\fP
.br
\fC#include 'lightsky/script/generic/variable_impl\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBls::script::variable\fP"
.br
.ti -1c
.RI "class \fBls::script::variable_t< hashId, type >\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBls\fP"
.br
.ti -1c
.RI " \fBls::script\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLS_SCRIPT_VAR_TYPE\fP(varType)   \fBls::script::variable_t\fP<\fBLS_SCRIPT_HASH_FUNC\fP(\fBLS_STRINGIFY\fP(varType)), varType>"
.br
.RI "\fIScript Variable Specifier\&. \fP"
.ti -1c
.RI "#define \fBLS_SCRIPT_VAR_DATA\fP(pVar, varName)   static_cast<scriptVar_##varName*>(pVar)->data"
.br
.RI "\fIScript Variable Data Access\&. \fP"
.ti -1c
.RI "#define \fBLS_SCRIPT_DECLARE_VAR\fP(varName, varType)"
.br
.RI "\fIVariable Declaration for Header Files\&. \fP"
.ti -1c
.RI "#define \fBLS_SCRIPT_DEFINE_VAR\fP(varName, varType)"
.br
.RI "\fIVariable Definition for Source Files\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBLS_SCRIPT_DECLARE_VAR\fP (char, char)"
.br
.ti -1c
.RI "\fBLS_SCRIPT_DECLARE_VAR\fP (short, short)"
.br
.ti -1c
.RI "\fBLS_SCRIPT_DECLARE_VAR\fP (int, int)"
.br
.ti -1c
.RI "\fBLS_SCRIPT_DECLARE_VAR\fP (long, long)"
.br
.ti -1c
.RI "\fBLS_SCRIPT_DECLARE_VAR\fP (float, float)"
.br
.ti -1c
.RI "\fBLS_SCRIPT_DECLARE_VAR\fP (double, double)"
.br
.ti -1c
.RI "\fBLS_SCRIPT_DECLARE_VAR\fP (string, std::string)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define LS_SCRIPT_DECLARE_VAR(varName, varType)"
\fBValue:\fP
.PP
.nf
\
        enum : ls::script::hash_t { scriptHash_##varName = LS_SCRIPT_HASH_FUNC(LS_STRINGIFY(varType)) }; \
        \
        extern const ls::script::varFactory scriptFactory_##varName; \
        \
        typedef ls::script::variable_t<scriptHash_##varName, varType> scriptVar_##varName; \
        \
        extern template class ls::script::variable_t<scriptHash_##varName, varType>
.fi
.PP
Variable Declaration for Header Files\&. This macro is used to both register a variable with the scripting system's global variable factory, as well as provide useful typedefs and a portable hash value to identify the variable type\&.
.PP
Sample usage would be as follows (for an integer and std::string): \fBLS_SCRIPT_DECLARE_VAR(int, int)\fP; \fBLS_SCRIPT_DECLARE_VAR(string, std::string)\fP; \fBLS_SCRIPT_DECLARE_VAR(someClassType, someClass::someType)\fP;
.PP
Now that there are two registered data types, one can access the hash codes for these two variable like so: scriptHash_int scriptHash_string scriptHash_someClassType
.PP
You could also create and modify registered variables: 
.PP
.nf
ls::script::variable* pVar = scriptFactory_int();
LS_SCRIPT_VAR_DATA(pVar, int) = 42;
delete pVar;

ls::script::variable* pVar = scriptFactory_string();
LS_SCRIPT_VAR_DATA(pVar, std::string) = "Hello World";
delete pVar;

ls::script::variable* pVar = scriptFactory_someClassType();
LS_SCRIPT_VAR_DATA(pVar, someClass::someType).foo();
delete pVar;

.fi
.PP
.PP
\fBNote:\fP
.RS 4
All data generated by a factory method MUST be deleted using 'delete\&.' 
.RE
.PP

.PP
Definition at line 300 of file variable\&.h\&.
.SS "#define LS_SCRIPT_DEFINE_VAR(varName, varType)"
\fBValue:\fP
.PP
.nf
\
        template class ls::script::variable_t<scriptHash_##varName, varType>; \
        \
        const ls::script::varFactory scriptFactory_##varName = \\
            ls::script::gVarFactory[ scriptHash_##varName ] = \
                []()->ls::script::variable* { return new scriptVar_##varName{}; }
.fi
.PP
Variable Definition for Source Files\&. This macro allows variable types to be defined in source compilation units\&. The macro explicitly instantiates the ls::script::variable_t<> class template, defines the variable's factory function, and adds the factory to the global factory map\&.
.PP
To use this macro, simply type: \fBLS_SCRIPT_DEFINE_VAR(int, int)\fP; \fBLS_SCRIPT_DEFINE_VAR(string, std::string)\fP; \fBLS_SCRIPT_DEFINE_VAR(someClassType, someClass::someType)\fP;
.PP
In addition, the global scripting factory can then be used like so: \fBls::script::variable\fP* pVar; pVar = ls::script::createScriptVar(scriptHash_int); \&.\&.\&. delete pVar; 
.PP
Definition at line 331 of file variable\&.h\&.
.SS "#define LS_SCRIPT_VAR_DATA(pVar, varName)   static_cast<scriptVar_##varName*>(pVar)->data"

.PP
Script Variable Data Access\&. This macro is intended to be used in the functor objects, but allows a scripted variable's data to be accessed in regular code\&.
.PP
To access the integer member of a scriptVar_int, for example, one could write the following: \fBLS_SCRIPT_VAR_DATA(foo, int)\fP = 42\&. 
.PP
Definition at line 260 of file variable\&.h\&.
.SS "#define LS_SCRIPT_VAR_TYPE(varType)   \fBls::script::variable_t\fP<\fBLS_SCRIPT_HASH_FUNC\fP(\fBLS_STRINGIFY\fP(varType)), varType>"

.PP
Script Variable Specifier\&. This is simply a convenience macro that can be used to access a \fBls::script::variable_t\fP by its data type, rather than specify it by its template parameters\&.
.PP
For example, a variable of type 'int' can be accessed in on of three ways: 
.PP
.nf
ls::script::variable_t<LS_SCRIPT_HASH_FUNC(LS_STRINGIFY(int)), int>

LS_SCRIPT_VAR_TYPE(int)

scriptVar_int (if registered using the LS_SCRIPT_DECLARE_VAR macro).
.fi
.PP
 
.PP
Definition at line 245 of file variable\&.h\&.
.SH "Function Documentation"
.PP 
.SS "LS_SCRIPT_DECLARE_VAR (char, char)"

.SS "LS_SCRIPT_DECLARE_VAR (short, short)"

.SS "LS_SCRIPT_DECLARE_VAR (int, int)"

.SS "LS_SCRIPT_DECLARE_VAR (long, long)"

.SS "LS_SCRIPT_DECLARE_VAR (float, float)"

.SS "LS_SCRIPT_DECLARE_VAR (double, double)"

.SS "LS_SCRIPT_DECLARE_VAR (string, std::string)"

.SH "Author"
.PP 
Generated automatically by Doxygen for LightSky from the source code\&.
