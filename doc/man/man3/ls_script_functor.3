.TH "ls::script::functor" 3 "Sun Oct 26 2014" "Version Pre-Alpha" "LightSky" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ls::script::functor \- 
.PP
Functor Base Class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <functor\&.h>\fP
.PP
Inherits \fBls::script::scriptable\fP\&.
.PP
Inherited by \fBls::script::functor_t< hashId, args_t >\fP, and \fBls::script::functor_t< hashId, void >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~functor\fP ()=0"
.br
.RI "\fIDestructor Frees all resources used by *this\&. \fP"
.ti -1c
.RI "\fBfunctor\fP ()=delete"
.br
.RI "\fIBasic constructor\&. \fP"
.ti -1c
.RI "\fBfunctor\fP (const \fBfunctor\fP &f)=delete"
.br
.RI "\fICopy Constructor\&. \fP"
.ti -1c
.RI "\fBfunctor\fP (\fBfunctor\fP &&f)=delete"
.br
.RI "\fIMove Constructor\&. \fP"
.ti -1c
.RI "\fBfunctor\fP & \fBoperator=\fP (const \fBfunctor\fP &f)"
.br
.RI "\fICopy Assignment\&. \fP"
.ti -1c
.RI "\fBfunctor\fP & \fBoperator=\fP (\fBfunctor\fP &&f)"
.br
.RI "\fIMove Assignment\&. \fP"
.ti -1c
.RI "\fBfunctor\fP * \fBgetNextFunc\fP ()"
.br
.RI "\fIGet the function that has been assigned to run after *this\&. \fP"
.ti -1c
.RI "void \fBsetNextFunc\fP (\fBfunctor\fP *const f)"
.br
.RI "\fIAssign a functor to run after *this\&. \fP"
.ti -1c
.RI "\fBscript_base_t\fP \fBgetScriptType\fP () const final"
.br
.RI "\fIGet *this object's scriptable type\&. \fP"
.ti -1c
.RI "virtual hash_t \fBgetScriptSubType\fP () const =0"
.br
.RI "\fIGet the run-time-type information of *this functor\&. \fP"
.ti -1c
.RI "virtual unsigned \fBgetNumArgs\fP () const =0"
.br
.RI "\fIRetrieve the number of arguments required to run *this\&. \fP"
.ti -1c
.RI "\fBvariable\fP * \fBgetArg\fP (unsigned index) const "
.br
.RI "\fIRetrieve an arguments from *this\&. \fP"
.ti -1c
.RI "void \fBsetArg\fP (unsigned index, \fBvariable\fP *v)"
.br
.RI "\fIAssign a variable to be functor argument\&. \fP"
.ti -1c
.RI "virtual bool \fBload\fP (std::istream &istr, \fBvarLoaderMap\fP &vlm, \fBfuncLoaderMap\fP &flm)"
.br
.RI "\fILoad functor data from an std::istream\&. \fP"
.ti -1c
.RI "virtual void \fBsave\fP (std::ostream &ostr) const "
.br
.RI "\fISave all data from *this into an std::ostream\&. \fP"
.ti -1c
.RI "virtual bool \fBcompile\fP ()=0"
.br
.RI "\fICompile/Verify function arguments\&. \fP"
.ti -1c
.RI "void \fBrun\fP ()"
.br
.RI "\fIRun a functor at run-time\&. \fP"
.ti -1c
.RI "template<typename arg_t , typename\&.\&.\&. args_t> bool \fBcheckArgs\fP (const \fBfunctor\fP &f, unsigned i, arg_t *t, args_t *\&.\&.\&.)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBfunctor\fP (\fBvariable\fP **const pArguments, const \fBfunc_ref_t\fP pFunc)"
.br
.RI "\fIProtected Constructor\&. \fP"
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "template<typename arg_t > static bool \fBcheckSingleArg\fP (const \fBfunctor\fP &f, unsigned i, arg_t *t)"
.br
.RI "\fIA verification method for single arguments\&. \fP"
.ti -1c
.RI "template<typename arg_t , typename\&.\&.\&. args_t> static bool \fBcheckArgs\fP (const \fBfunctor\fP &f, unsigned i, arg_t *t, args_t *\&.\&.\&.ts)"
.br
.RI "\fIA verification method for single arguments\&. \fP"
.ti -1c
.RI "template<typename arg_t > static bool \fBcheckArgs\fP (const \fBfunctor\fP &f, unsigned i, arg_t *t)"
.br
.RI "\fIA verification method for single arguments\&. \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBfunctor\fP * \fBnextFunc\fP = nullptr"
.br
.RI "\fIthe 'nextFunc' member is a pointer to another function that can be run after *this\&. \fP"
.ti -1c
.RI "const \fBfunc_ref_t\fP \fBpFunction\fP"
.br
.RI "\fI'pFunction' is a reference to a native function wrapper\&. \fP"
.ti -1c
.RI "\fBvariable\fP **const \fBpArgs\fP"
.br
.RI "\fIAn array of pointers to variables\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Functor Base Class\&. 


.PP
 The functor base class is constructed with a reference to a native C/C++ function\&. It contains methods to store and load its parameters from a 
.SS "script file, self-compile, and change its arguments at runtime\&. "

.PP
Definition at line 40 of file functor\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ls::script::functor::functor (\fBvariable\fP **constpArguments, const \fBfunc_ref_t\fPpFunc)\fC [protected]\fP"

.PP
Protected Constructor\&. This constructor MUST be called by any derived functor constructors in order to properly initialize *this and all members contained in *this\&. 
.PP
Definition at line 27 of file functor\&.cpp\&.
.SS "ls::script::functor::~functor ()\fC [pure virtual]\fP"

.PP
Destructor Frees all resources used by *this\&. 
.PP
Definition at line 21 of file functor\&.cpp\&.
.SS "ls::script::functor::functor ()\fC [delete]\fP"

.PP
Basic constructor\&. This constructor has been deleted due to the need for construction of protected members by derived classes\&. 
.SS "ls::script::functor::functor (const \fBfunctor\fP &f)\fC [delete]\fP"

.PP
Copy Constructor\&. This constructor has been deleted due to the need for construction of protected members by derived classes\&. 
.SS "ls::script::functor::functor (\fBfunctor\fP &&f)\fC [delete]\fP"

.PP
Move Constructor\&. This constructor has been deleted due to the need for construction of protected members by derived classes\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename arg_t , typename\&.\&.\&. args_t> static bool ls::script::functor::checkArgs (const \fBfunctor\fP &f, unsignedi, arg_t *t, args_t *\&.\&.\&.ts)\fC [static]\fP, \fC [protected]\fP"

.PP
A verification method for single arguments\&. This is similar to the 'compile' method, but allows one to check a single functor argument and verify that it is safe to operate at run-time\&. This is explicitly called for each argument when calling the '\fBcompile()\fP' method\&.
.PP
\fBParameters:\fP
.RS 4
\fIg\fP A constant reference to a functor object\&.
.br
\fIi\fP The index of the argument in 'f' to verify\&.
.br
\fIt\fP A dummy type which allows argument type information to be matched against something\&.
.br
\fIts\fP Addition types for subsequent argument matching\&.
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE if the argument in 'f', specified by 'i', is able to be used, FALSE if not\&. 
.RE
.PP

.SS "template<typename arg_t , typename\&.\&.\&. args_t> bool ls::script::functor::checkArgs (const \fBfunctor\fP &f, unsignedi, arg_t *t, args_t *\&.\&.\&.)\fC [inline]\fP"

.PP
Definition at line 98 of file functor_impl\&.h\&.
.SS "template<typename arg_t > bool ls::script::functor::checkArgs (const \fBfunctor\fP &f, unsignedi, arg_t *t)\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP"

.PP
A verification method for single arguments\&. This is similar to the 'compile' method, but allows one to check a single functor argument and verify that it is safe to operate at run-time\&. This is explicitly called for each argument when calling the '\fBcompile()\fP' method\&.
.PP
\fBParameters:\fP
.RS 4
\fIg\fP A constant reference to a functor object\&.
.br
\fIi\fP The index of the argument in 'f' to verify\&.
.br
\fIt\fP A dummy type which allows argument type information to be matched against something\&.
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE if the argument in 'f', specified by 'i', is able to be used, FALSE if not\&. 
.RE
.PP

.PP
Definition at line 107 of file functor_impl\&.h\&.
.SS "template<typename arg_t > bool ls::script::functor::checkSingleArg (const \fBfunctor\fP &f, unsignedi, arg_t *t)\fC [static]\fP, \fC [protected]\fP"

.PP
A verification method for single arguments\&. This is similar to the 'compile' method, but allows one to check a single functor argument and verify that it is safe to operate at run-time\&. This is explicitly called for each argument when calling the '\fBcompile()\fP' method\&.
.PP
\fBParameters:\fP
.RS 4
\fIg\fP A constant reference to a functor object\&.
.br
\fIi\fP The index of the argument in 'f' to verify\&.
.br
\fIt\fP A dummy type which allows argument type information to be matched against something\&.
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE if the argument in 'f', specified by 'i', is able to be used, FALSE if not\&. 
.RE
.PP

.PP
Definition at line 54 of file functor_impl\&.h\&.
.SS "virtual bool ls::script::functor::compile ()\fC [pure virtual]\fP"

.PP
Compile/Verify function arguments\&. This method ensures that a functor is safe to operate at run-time\&. It uses custom RTTI information, combined with derived-type's template parameters to ensure that the proper arguments are placed in the correct order at run-time\&.
.PP
\fBNote:\fP
.RS 4
Because the scripting system does not manage the order in which you actually use arguments, please ensure that your functor-mapping code is consistent with the derived functor's template parameters\&.
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE if a functor managed to compile correctly, FALSE if not\&. If this function returns false, please check std::cerr for information on what went wrong\&. This will be changed in the future in order to provide more convenient error tracking\&. 
.RE
.PP

.PP
Implemented in \fBls::script::functor_t< hashId, void >\fP, and \fBls::script::functor_t< hashId, args_t >\fP\&.
.SS "\fBvariable\fP * ls::script::functor::getArg (unsignedindex) const\fC [inline]\fP"

.PP
Retrieve an arguments from *this\&. The number of arguments to the functor is not always the same number of arguments that *this functor's native function needs\&. Functor arguments can be mapped to return values, or to sequences of internal functions\&. It is up to the definition code to determine where functor arguments are mapped\&.
.PP
\fBReturns:\fP
.RS 4
A pointer to an internal variable that will be used to run *this\&. 
.RE
.PP

.PP
Definition at line 36 of file functor_impl\&.h\&.
.SS "\fBfunctor\fP * ls::script::functor::getNextFunc ()\fC [inline]\fP"

.PP
Get the function that has been assigned to run after *this\&. Functors in the scripting system are linked to each other by pointers\&. When another function is assigned as the 'next' functor, then it will run after *this one has completed\&.
.PP
\fBReturns:\fP
.RS 4
a pointer to the functor object which has been assigned to run after *this\&. 
.RE
.PP

.PP
Definition at line 12 of file functor_impl\&.h\&.
.SS "virtual unsigned ls::script::functor::getNumArgs () const\fC [pure virtual]\fP"

.PP
Retrieve the number of arguments required to run *this\&. The number of arguments to the functor is not always the same number of arguments that *this functor's native function needs\&. Functor arguments can be mapped to return values, or to sequences of internal functions\&. It is up to the definition code to determine where functor arguments are mapped\&.
.PP
\fBReturns:\fP
.RS 4
An unsigned integral type, indicating how many arguments *this functor needs to run\&. 
.RE
.PP

.PP
Implemented in \fBls::script::functor_t< hashId, void >\fP, and \fBls::script::functor_t< hashId, args_t >\fP\&.
.SS "virtual hash_t ls::script::functor::getScriptSubType () const\fC [pure virtual]\fP"

.PP
Get the run-time-type information of *this functor\&. This method will return a hash-code, indicating what type of functor *this is\&. The has code is unique to types of functors, not individual functor objects\&. This hash code is used by the global script factories in order to generate a functor at run-time\&.
.PP
\fBReturns:\fP
.RS 4
hash_t A hash-code that will identify the RTTI information of *this\&. 
.RE
.PP

.PP
Implements \fBls::script::scriptable\fP\&.
.PP
Implemented in \fBls::script::functor_t< hashId, void >\fP, and \fBls::script::functor_t< hashId, args_t >\fP\&.
.SS "\fBscript_base_t\fP ls::script::functor::getScriptType () const\fC [inline]\fP, \fC [final]\fP, \fC [virtual]\fP"

.PP
Get *this object's scriptable type\&. 
.PP
\fBReturns:\fP
.RS 4
\fBscript_base_t::SCRIPT_FUNC\fP 
.RE
.PP

.PP
Implements \fBls::script::scriptable\fP\&.
.PP
Definition at line 28 of file functor_impl\&.h\&.
.SS "bool ls::script::functor::load (std::istream &istr, \fBvarLoaderMap\fP &vlm, \fBfuncLoaderMap\fP &flm)\fC [virtual]\fP"

.PP
Load functor data from an std::istream\&. A serialization method to will help reload data from a standard input stream\&. This method uses the overloaded input stream operator 'std::istream::operator>> (T)' in order to load functor data into *this\&.
.PP
\fBParameters:\fP
.RS 4
\fIistr\fP A reference to a std::istream object which contains functor data to be loaded into *this\&.
.br
\fIvlm\fP A variable-loading factory that will be used to map variable data from the input stream into *this\&.
.br
\fIflm\fP A function-loading factory that will be used to map functor data from the input stream into *this\&.
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value that will determine if data was successfully loaded into *this (TRUE) or not (FALSE)\&. 
.RE
.PP

.PP
Implements \fBls::script::scriptable\fP\&.
.PP
Reimplemented in \fBls::script::functor_t< hashId, void >\fP, and \fBls::script::functor_t< hashId, args_t >\fP\&.
.PP
Definition at line 68 of file functor\&.cpp\&.
.SS "\fBfunctor\fP & ls::script::functor::operator= (const \fBfunctor\fP &f)"

.PP
Copy Assignment\&. Copies pointers of arguments from the input parameter into *this\&. Remember to compile *this after a copy is performed in order to ensure program stability\&.
.PP
\fBParameters:\fP
.RS 4
\fIf\fP A constant reference to a functor object with the same signature as *this\&.
.RE
.PP
\fBReturns:\fP
.RS 4
a reference to *this\&. 
.RE
.PP

.PP
Definition at line 37 of file functor\&.cpp\&.
.SS "\fBfunctor\fP & ls::script::functor::operator= (\fBfunctor\fP &&f)"

.PP
Move Assignment\&. Moves pointers of arguments from the input parameter into *this\&. Remember to compile *this after a move is performed in order to ensure program stability\&.
.PP
\fBParameters:\fP
.RS 4
\fIf\fP An r-value reference to a functor object with the same signature as *this\&.
.RE
.PP
\fBReturns:\fP
.RS 4
a reference to *this\&. 
.RE
.PP

.PP
Definition at line 51 of file functor\&.cpp\&.
.SS "void ls::script::functor::run ()\fC [inline]\fP"

.PP
Run a functor at run-time\&. 
.PP
Definition at line 90 of file functor_impl\&.h\&.
.SS "void ls::script::functor::save (std::ostream &ostr) const\fC [virtual]\fP"

.PP
Save all data from *this into an std::ostream\&. In this instance, functors, references to other functors, and variables are all saved using RTTI information\&. Scriptable objects are not saved, just their type-info\&. All data is mapped to/from the 'loaderMap' objects in order to ensure cross-references are maintained when reloaded from an input stream\&.
.PP
\fBParameters:\fP
.RS 4
\fIostr\fP A reference to an std::ostream object\&. 
.RE
.PP

.PP
Implements \fBls::script::scriptable\fP\&.
.PP
Reimplemented in \fBls::script::functor_t< hashId, void >\fP, and \fBls::script::functor_t< hashId, args_t >\fP\&.
.PP
Definition at line 87 of file functor\&.cpp\&.
.SS "void ls::script::functor::setArg (unsignedindex, \fBvariable\fP *v)\fC [inline]\fP"

.PP
Assign a variable to be functor argument\&. The number of arguments to the functor is not always the same number of arguments that *this functor's native function needs\&. Functor arguments can be mapped to return values, or to sequences of internal functions\&. It is up to the definition code to determine where functor arguments are mapped\&.
.PP
\fBNote:\fP
.RS 4
Always remember to recompile your functors after manipulating functor arguments to ensure they don't crash at run-time\&. The scripting system provides the means to verify type information but does not perform these checks for you\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIv\fP A pointer to an variable object that will be used to run *this\&. 
.RE
.PP

.PP
Definition at line 45 of file functor_impl\&.h\&.
.SS "void ls::script::functor::setNextFunc (\fBfunctor\fP *constf)\fC [inline]\fP"

.PP
Assign a functor to run after *this\&. Functors in the scripting system are linked to each other by pointers\&. When another function is assigned as the 'next' functor, then it will run after *this one has completed\&.
.PP
\fBParameters:\fP
.RS 4
\fIf\fP A pointer to a functor object\&. If the input parameter is NULL, then the function sequence will halt after this functor has completed its '\fBrun()\fP' method\&. 
.RE
.PP

.PP
Definition at line 20 of file functor_impl\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBfunctor\fP* ls::script::functor::nextFunc = nullptr\fC [protected]\fP"

.PP
the 'nextFunc' member is a pointer to another function that can be run after *this\&. This member allows functions to be chained together at runtime, creating a linked-list of functions\&. 
.PP
Definition at line 124 of file functor\&.h\&.
.SS "\fBvariable\fP** const ls::script::functor::pArgs\fC [protected]\fP"

.PP
An array of pointers to variables\&. Retaining an array of argument pointers allows variables to be mapped to functors at run-time\&. 
.PP
Definition at line 142 of file functor\&.h\&.
.SS "const \fBfunc_ref_t\fP ls::script::functor::pFunction\fC [protected]\fP"

.PP
'pFunction' is a reference to a native function wrapper\&. This member references a wrapper function which takes an array of script variables as parameters\&. Use the wrapper function to map argument parameters to actual, native parameters and a return value\&. 
.PP
Definition at line 134 of file functor\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for LightSky from the source code\&.
