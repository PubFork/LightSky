.TH "C:/Users/miles/C++/projects/LightSky/lightsky/script/functor.h" 3 "Sun Oct 26 2014" "Version Pre-Alpha" "LightSky" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/miles/C++/projects/LightSky/lightsky/script/functor.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <iostream>\fP
.br
\fC#include <utility>\fP
.br
\fC#include <typeinfo>\fP
.br
\fC#include 'lightsky/utils/assert\&.h'\fP
.br
\fC#include 'lightsky/script/setup\&.h'\fP
.br
\fC#include 'lightsky/script/scriptable\&.h'\fP
.br
\fC#include 'lightsky/script/variable\&.h'\fP
.br
\fC#include 'lightsky/script/generic/functor_impl\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBls::script::functor\fP"
.br
.RI "\fIFunctor Base Class\&. \fP"
.ti -1c
.RI "singleton \fBls::script::functor_t< hashId, args_t >\fP"
.br
.RI "\fIFunctor Class Template Type\&. \fP"
.ti -1c
.RI "class \fBls::script::functor_t< hashId, void >\fP"
.br
.RI "\fI
.SS "Functor Template Type with Void Parameters "
\fP"
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBls\fP"
.br
.ti -1c
.RI " \fBls::script\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLS_SCRIPT_DECLARE_FUNC\fP(funcName,\&.\&.\&.)"
.br
.RI "\fIFunctor Declaration for Header Files\&. \fP"
.ti -1c
.RI "#define \fBLS_SCRIPT_DEFINE_FUNC\fP(funcName,\&.\&.\&.)"
.br
.RI "\fIFunction Definition for source files\&. \fP"
.ti -1c
.RI "#define \fBLS_SCRIPT_PARAM\fP(index, varType)   static_cast<varType*>(pArgs[index])->data"
.br
.RI "\fIFunction Argument Accessibility\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(&) \fBls::script::func_ref_t\fP (variable **const)"
.br
.RI "\fIfunc_ref_t is a reference-to-function typedef to make things easier to understand in-code\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBLS_SCRIPT_DECLARE_FUNC\fP (empty, void)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define LS_SCRIPT_DECLARE_FUNC(funcName, \&.\&.\&.)"
\fBValue:\fP
.PP
.nf
\
    enum : ls::script::hash_t { \
        scriptHash_##funcName = LS_SCRIPT_HASH_FUNC(LS_STRINGIFY(funcName)) \
    }; \
    \
    typedef ls::script::functor_t<scriptHash_##funcName, __VA_ARGS__> scriptFunc_##funcName; \
    \
    extern const ls::script::funcFactory scriptFactory_##funcName; \
    \
    extern template class ls::script::functor_t<scriptHash_##funcName, __VA_ARGS__>
.fi
.PP
Functor Declaration for Header Files\&. Use this macro in a header file in order to declare a functor and provide global access to the script type to be used\&.
.PP
For example, use it as follows: \fBLS_SCRIPT_DECLARE_FUNC(addNums, scriptVar_int, scriptVar_int)\fP; \fBLS_SCRIPT_DECLARE_FUNC(strcat, scriptVar_string, scriptVar_string, scriptVar_string)\fP;
.PP
The sample above will provide the declarations, hashes, and factories for two new functors\&. These functors themselves can be referenced like so: 'scriptFunc_addNums' and 'scriptFunc_strcat'
.PP
The hashes can be referenced as such: 'scriptHash_addNums' and 'scriptHash_strcat'
.PP
And the factory methods are accessible like this: \fBls::script::functor\fP* pFunc; pFunc = ls::script::createScriptFunc(scriptHash_addNums); \&.\&.\&. delete pFunc;
.PP
pFunc = ls::script::createScriptFunc(scriptHash_strcat); \&.\&.\&. delete pFunc; 
.PP
Definition at line 759 of file functor\&.h\&.
.SS "#define LS_SCRIPT_DEFINE_FUNC(funcName, \&.\&.\&.)"
\fBValue:\fP
.PP
.nf
template class ls::script::functor_t<scriptHash_##funcName, __VA_ARGS__>; \
    \
    const ls::script::funcFactory scriptFactory_##funcName = \\
        ls::script::gFuncFactory[scriptHash_##funcName] = \
            []()->ls::script::functor* { return new scriptFunc_##funcName{}; }; \
    \
    template <> \
    const ls::script::func_ref_t \
    scriptFunc_##funcName::functionImpl = *[](ls::script::variable** const pArgs)->void
.fi
.PP
Function Definition for source files\&. The definition of functors MUST define how arguments will be mapped to native functions\&. For example, to use this, simply write as follows: 
.PP
.nf
LS_SCRIPT_DEFINE_FUNC(addNums, scriptVar_int, scriptVar_int) {
    LS_SCRIPT_PARAM(0, scriptVar_int) += LS_SCRIPT_PARAM(1, scriptVar_int);
};

LS_SCRIPT_DEFINE_FUNC(strcat, scriptVar_string, scriptVar_string, scriptVar_string) {
    LS_SCRIPT_PARAM(0, scriptVar_string)
        = LS_SCRIPT_PARAM(1, scriptVar_string)
        + LS_SCRIPT_PARAM(2, scriptVar_string);
};

.fi
.PP
.PP
Although a bit verbose, the process is actually quite painless once you get used to it\&. As shown above, functor arguments/parameters are accessible through both indices and types\&. In order to ensure that the proper types get used by a functor, make sure that the 'compile()' method is called and returns TRUE before running a functor\&.
.PP
Finally, defining a functor using this macro enables linkage to the global factory methods\&. A functor can now be spawned in the following manner: \fBls::script::functor\fP* pFunc; pFunc = ls::script::createScriptFunc(scriptHash_addNums); if (pFunc->compile()) { pFunc->run(); } delete pFunc; 
.PP
Definition at line 803 of file functor\&.h\&.
.SS "#define LS_SCRIPT_PARAM(index, varType)   static_cast<varType*>(pArgs[index])->data"

.PP
Function Argument Accessibility\&. Use this macro to access arguments/parameters when defining the functor\&. For example, use it like this: 
.PP
.nf
LS_SCRIPT_DEFINE_FUNC(addNums, scriptVar_int, scriptVar_int) {
    LS_SCRIPT_PARAM(0, scriptVar_int) += LS_SCRIPT_PARAM(1, scriptVar_int);
};

LS_SCRIPT_DEFINE_FUNC(strcat, scriptVar_string, scriptVar_string, scriptVar_string) {
    LS_SCRIPT_PARAM(0, scriptVar_string)
        = LS_SCRIPT_PARAM(1, scriptVar_string)
        + LS_SCRIPT_PARAM(2, scriptVar_string);
};
.fi
.PP
 
.PP
Definition at line 830 of file functor\&.h\&.
.SH "Function Documentation"
.PP 
.SS "LS_SCRIPT_DECLARE_FUNC (empty, void)"

.SH "Author"
.PP 
Generated automatically by Doxygen for LightSky from the source code\&.
