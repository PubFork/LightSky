.TH "ls::utils" 3 "Sun Oct 26 2014" "Version Pre-Alpha" "LightSky" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ls::utils \- 
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fButilsImpl\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBbitMask\fP"
.br
.RI "\fI\fBbitMask\fP Convenience structure to facilitate bit acquisition of bytes\&. \fP"
.ti -1c
.RI "class \fBbTree\fP"
.br
.RI "\fIB-Tree A simple tree container that allows for fast lookup of data\&. \fP"
.ti -1c
.RI "class \fBbTreeNode\fP"
.br
.RI "\fIBTree Node A node type used by the BTree class in order to store data\&. \fP"
.ti -1c
.RI "class \fBdataResource\fP"
.br
.RI "\fIBasic memory object/file abstraction\&. \fP"
.ti -1c
.RI "class \fBrandomNum\fP"
.br
.RI "\fIPseudo-randomn number generator using the WELLRNC 512 algorithm\&. \fP"
.ti -1c
.RI "class \fBresource\fP"
.br
.RI "\fIBasic file/resource abstraction\&. \fP"
.ti -1c
.RI "class \fBtuple_t\fP"
.br
.RI "\fITuple Class An tuple is a set of objects determined at compile-time\&. These objects are constructed within a tightly packed buffer\&. It is recommended to construct an tuple using the 'new' operator if there are many objects\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint32_t \fBhash_t\fP"
.br
.RI "\fIhash_t An integral type that's long enough to hold a simple hash value\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBerror_t\fP : int { \fBALERT\fP, \fBWARNING\fP, \fBERROR\fP }"
.br
.RI "\fIerror_t A basic enumeration for lightsky assertions\&. \fP"
.ti -1c
.RI "enum \fBbnode_dir_t\fP : unsigned { \fBBNODE_LEFT\fP = 0, \fBBNODE_RIGHT\fP = 1, \fBBNODE_MAX\fP }"
.br
.RI "\fIbnode_dir_t A simple enumeration to help determine where within a btree-node a child node should be placed\&. \fP"
.ti -1c
.RI "enum \fBendian_t\fP : uint32_t { \fBLS_LITTLE_ENDIAN\fP = 0x00000001, \fBLS_BIG_ENDIAN\fP = 0x01000000, \fBLS_PDP_ENDIAN\fP = 0x00010000, \fBLS_UNKNOWN_ENDIAN\fP = 0xFFFFFFFF }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBruntime_assert\fP (bool condition, \fBerror_t\fP type, const char *const msg)"
.br
.RI "\fIruntime_assert Throw an \fBls::utils::error_t\fP and/or send a message to stdout/stderr\&. \fP"
.ti -1c
.RI "template<typename key_t > constexpr const \fBbitMask\fP * \fBgetByte\fP (const key_t *key, unsigned iter)"
.br
.RI "\fIgetByte Retrieve the Nth byte of a basic data type\&. \fP"
.ti -1c
.RI "template<> constexpr const \fBbitMask\fP * \fBgetByte\fP (const char *key, unsigned iter)"
.br
.RI "\fIgetByte (char string specialization) Retrieve the Nth byte of a basic data type\&. \fP"
.ti -1c
.RI "template<> constexpr const \fBbitMask\fP * \fBgetByte\fP (const wchar_t *key, unsigned iter)"
.br
.RI "\fIgetByte (wchar_t string specialization) Retrieve the Nth byte of a basic data type\&. \fP"
.ti -1c
.RI "template<> constexpr const \fBbitMask\fP * \fBgetByte\fP (const char16_t *key, unsigned iter)"
.br
.RI "\fIgetByte (char16_t string specialization) Retrieve the Nth byte of a basic data type\&. \fP"
.ti -1c
.RI "template<> constexpr const \fBbitMask\fP * \fBgetByte\fP (const char32_t *key, unsigned iter)"
.br
.RI "\fIgetByte (char32_t string specialization) Retrieve the Nth byte of a basic data type\&. \fP"
.ti -1c
.RI "constexpr unsigned \fBgetArgByteSize\fP (unsigned size)"
.br
.RI "\fIgetArgByteSize Helper function to sum the number of bytes used by a set of types\&. \fP"
.ti -1c
.RI "template<typename\&.\&.\&. integral_t> constexpr unsigned \fBgetArgByteSize\fP (unsigned size, integral_t\&.\&.\&.sizeN)"
.br
.RI "\fIgetArgByteSize Helper function to sum the number of bytes used by a set of types\&. \fP"
.ti -1c
.RI "template<typename\&.\&.\&. integral_t> constexpr unsigned \fBgetByteSize\fP ()"
.br
.RI "\fIgetByteSize Sum the number of bytes used by a set of types\&. \fP"
.ti -1c
.RI "constexpr \fBendian_t\fP \fBgetEndianOrder\fP ()"
.br
.ti -1c
.RI "constexpr uint16_t \fBbtol\fP (uint16_t n)"
.br
.ti -1c
.RI "constexpr int16_t \fBbtol\fP (int16_t n)"
.br
.ti -1c
.RI "constexpr uint32_t \fBbtol\fP (uint32_t n)"
.br
.ti -1c
.RI "constexpr int32_t \fBbtol\fP (int32_t n)"
.br
.ti -1c
.RI "constexpr uint64_t \fBbtol\fP (uint64_t n)"
.br
.ti -1c
.RI "constexpr int64_t \fBbtol\fP (int64_t n)"
.br
.ti -1c
.RI "template<typename num_t > num_t \fBbtol\fP (num_t n)"
.br
.ti -1c
.RI "constexpr \fBhash_t\fP \fBhashDJB2_impl\fP (const char *str, unsigned int hashVal)"
.br
.ti -1c
.RI "constexpr \fBhash_t\fP \fBhashDJB2\fP (const char *str)"
.br
.RI "\fIDJB2 Hashing Function This hash algorithm was found on here: http://nguillemot.blogspot.com/2012/06/side-story-compile-time-string-hashing.html\&. \fP"
.ti -1c
.RI "constexpr \fBhash_t\fP \fBhashSDBM_impl\fP (const char *str, unsigned int hashVal)"
.br
.ti -1c
.RI "constexpr \fBhash_t\fP \fBhashSDBM\fP (const char *str)"
.br
.RI "\fISDBM Hashing Function This hash algorithm was found here: http://www.cse.yorku.ca/~oz/hash.html\&. \fP"
.ti -1c
.RI "constexpr \fBhash_t\fP \fBhashFNV1_impl\fP (const char *str, unsigned int hashVal)"
.br
.ti -1c
.RI "constexpr \fBhash_t\fP \fBhashFNV1\fP (const char *str)"
.br
.RI "\fIFNV-1a Hashing Function This hash algorithm was found here: http://www.eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx\&. \fP"
.ti -1c
.RI "constexpr \fBhash_t\fP \fBcrc32\fP (const char *str, \fBhash_t\fP prevCrc)"
.br
.ti -1c
.RI "template<typename Arg > void \fBlogMsg\fP (const Arg &arg)"
.br
.ti -1c
.RI "template<typename Arg , typename\&.\&.\&. Args> void \fBlogMsg\fP (const Arg &arg, const Args &\&.\&.\&.args)"
.br
.ti -1c
.RI "template<typename Arg > void \fBlogErr\fP (const Arg &arg)"
.br
.ti -1c
.RI "template<typename Arg , typename\&.\&.\&. Args> void \fBlogErr\fP (const Arg &arg, const Args &\&.\&.\&.args)"
.br
.ti -1c
.RI "constexpr \fBhash_t\fP \fBhashCRC32\fP (const char *str, \fBhash_t\fP prevCrc=0xFFFFFFFF)"
.br
.RI "\fICRC32 Hashing function A simple compile-time hashing function using the CRC32 algorithm\&. \fP"
.ti -1c
.RI "template<typename arg_t > void \fBlogMsg\fP (const arg_t &arg)"
.br
.RI "\fIPrint multiple parameters to std::cout\&. \fP"
.ti -1c
.RI "template<typename arg_t , typename\&.\&.\&. args_t> void \fBlogMsg\fP (const arg_t &arg, const args_t &\&.\&.\&.args)"
.br
.RI "\fIPrint multiple parameters to std::cout\&. \fP"
.ti -1c
.RI "template<typename arg_t > void \fBlogErr\fP (const arg_t &arg)"
.br
.RI "\fIPrint multiple parameters to std::cerr\&. \fP"
.ti -1c
.RI "template<typename arg_t , typename\&.\&.\&. args_t> void \fBlogErr\fP (const arg_t &arg, const args_t &\&.\&.\&.args)"
.br
.RI "\fIPrint multiple parameters to std::cerr\&. \fP"
.ti -1c
.RI "template<typename T > std::string \fBtoString\fP (const T &data)"
.br
.RI "\fIConvert a basic data type to an std::string\&. \fP"
.ti -1c
.RI "std::string \fBconvertWtoMb\fP (const std::wstring &wstr)"
.br
.RI "\fIConvert a Wide String to a Multi-Byte Character String\&. \fP"
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef uint32_t \fBls::utils::hash_t\fP"

.PP
hash_t An integral type that's long enough to hold a simple hash value\&. 
.PP
Definition at line 28 of file hash\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBls::utils::bnode_dir_t\fP : unsigned"

.PP
bnode_dir_t A simple enumeration to help determine where within a btree-node a child node should be placed\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIBNODE_LEFT \fP\fP
.TP
\fB\fIBNODE_RIGHT \fP\fP
.TP
\fB\fIBNODE_MAX \fP\fP
.PP
Definition at line 24 of file btree\&.h\&.
.SS "enum \fBls::utils::endian_t\fP : uint32_t"
This enumeration can be placed into templated objects in order to generate compile-time code based on a program's target endianness\&.
.PP
The values placed in this enum are used just in case the need arises in order to manually compare them against the number order in the endianValues[] array\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fILS_LITTLE_ENDIAN \fP\fP
.TP
\fB\fILS_BIG_ENDIAN \fP\fP
.TP
\fB\fILS_PDP_ENDIAN \fP\fP
.TP
\fB\fILS_UNKNOWN_ENDIAN \fP\fP
.PP
Definition at line 26 of file endian\&.h\&.
.SS "enum \fBls::utils::error_t\fP : int"

.PP
error_t A basic enumeration for lightsky assertions\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIALERT \fP\fP
ALERT when used with runtime_assert, this indicates that a message will print to std::cout\&. 
.TP
\fB\fIWARNING \fP\fP
WARNING when used with runtime_assert, this indicates that a message will print to std::cerr\&. 
.TP
\fB\fIERROR \fP\fP
ERROR when used with runtime_assert, this indicates that a message will print to std::cerr, and an exception of type \fBls::utils::error_t\fP is thrown\&. 
.PP
Definition at line 14 of file assert\&.h\&.
.SH "Function Documentation"
.PP 
.SS "constexpr uint16_t ls::utils::btol (uint16_tn)"
Swap the bytes of an unsigned 16-bit integral type between big and little endian representation\&. This function can be used at compile-time\&.
.PP
\fBParameters:\fP
.RS 4
\fIn\fP an unsigned integral type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
uint16_t The value of the input parameter with its bytes swapped between big & little endian representation\&. 
.RE
.PP

.PP
Definition at line 61 of file endian\&.h\&.
.SS "constexpr int16_t ls::utils::btol (int16_tn)"
Swap the bytes of a signed 16-bit integral type between big and little endian representation\&. This function can be used at compile-time\&.
.PP
\fBParameters:\fP
.RS 4
\fIn\fP a signed integral type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
int16_t The value of the input parameter with its bytes swapped between big & little endian representation\&. 
.RE
.PP

.PP
Definition at line 77 of file endian\&.h\&.
.SS "constexpr uint32_t ls::utils::btol (uint32_tn)"
Swap the bytes of an unsigned 32-bit integral type between big and little endian representation\&. This function can be used at compile-time\&.
.PP
\fBParameters:\fP
.RS 4
\fIn\fP an unsigned integral type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
uint32_t The value of the input parameter with its bytes swapped between big & little endian representation\&. 
.RE
.PP

.PP
Definition at line 93 of file endian\&.h\&.
.SS "constexpr int32_t ls::utils::btol (int32_tn)"
Swap the bytes of a signed 32-bit integral type between big and little endian representation\&. This function can be used at compile-time\&.
.PP
\fBParameters:\fP
.RS 4
\fIn\fP a signed integral type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
int32_t The value of the input parameter with its bytes swapped between big & little endian representation\&. 
.RE
.PP

.PP
Definition at line 113 of file endian\&.h\&.
.SS "constexpr uint64_t ls::utils::btol (uint64_tn)"
Swap the bytes of an unsigned 64-bit integral type between big and little endian representation\&. This function can be used at compile-time\&.
.PP
\fBParameters:\fP
.RS 4
\fIn\fP an unsigned integral type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
uint64_t The value of the input parameter with its bytes swapped between big & little endian representation\&. 
.RE
.PP

.PP
Definition at line 129 of file endian\&.h\&.
.SS "constexpr int64_t ls::utils::btol (int64_tn)"
Swap the bytes of a signed 64-bit integral type between big and little endian representation\&. This function can be used at compile-time\&.
.PP
\fBParameters:\fP
.RS 4
\fIn\fP a signed integral type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
int64_t The value of the input parameter with its bytes swapped between big & little endian representation\&. 
.RE
.PP

.PP
Definition at line 153 of file endian\&.h\&.
.SS "template<typename num_t > num_t ls::utils::btol (num_tn)"
Swap the bytes of a POD type between big and little endian representation\&.
.PP
\fBParameters:\fP
.RS 4
\fIn\fP A plain-old-data type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
num_t The value of the input parameter with its bytes swapped between big & little endian representation\&. 
.RE
.PP

.PP
Definition at line 168 of file endian\&.h\&.
.SS "std::string ls::utils::convertWtoMb (const std::wstring &wstr)"

.PP
Convert a Wide String to a Multi-Byte Character String\&. This function assists in making an application cope with UTF-8 and UTF-16 compatibility issues\&.
.PP
\fBParameters:\fP
.RS 4
\fIwstr\fP A wide-character string object which needs to be converted into a multi-byte string representation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
std::string A std::string object that uses 'char' types instead of the input parameter's 'wchar_t' type\&. 
.RE
.PP

.PP
Definition at line 19 of file string_utils\&.cpp\&.
.SS "constexpr \fBhash_t\fP ls::utils::crc32 (const char *str, hash_tprevCrc)"

.PP
Definition at line 126 of file hash_impl\&.h\&.
.SS "constexpr unsigned ls::utils::getArgByteSize (unsignedsize)"

.PP
getArgByteSize Helper function to sum the number of bytes used by a set of types\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP An unsigned integer representing the size, in bytes, of an object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
An unsigned integer, representing the size, in bytes, of an object\&. This can be the size of a built-in type, or user-defined structures\&. 
.RE
.PP

.PP
Definition at line 8 of file byteSize_impl\&.h\&.
.SS "template<typename\&.\&.\&. integral_t> constexpr unsigned ls::utils::getArgByteSize (unsignedsize, integral_t\&.\&.\&.sizeN)"

.PP
getArgByteSize Helper function to sum the number of bytes used by a set of types\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP An unsigned integer representing the size, in bytes, of an object\&.
.br
\fIsizeN\fP A set of unsigned integers that contain the byte size of a set of objects\&.
.RE
.PP
\fBReturns:\fP
.RS 4
An unsigned integer, representing the size, in bytes, of a set of object types\&. These types can be built-in, or user-defined structures\&. 
.RE
.PP

.PP
Definition at line 16 of file byteSize_impl\&.h\&.
.SS "template<typename key_t > constexpr const \fBbitMask\fP* ls::utils::getByte (const key_t *key, unsignediter)"

.PP
getByte Retrieve the Nth byte of a basic data type\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP 
.br
\fIiter\fP The iterator which specifies the Nth byte in 'key'\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The Nth byte in 'key,' specified by 'iter\&.' 
.RE
.PP

.SS "template<> constexpr const \fBbitMask\fP* ls::utils::getByte (const char *key, unsignediter)"

.PP
getByte (char string specialization) Retrieve the Nth byte of a basic data type\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP 
.br
\fIiter\fP The iterator which specifies the Nth byte in 'key'\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The Nth byte in 'key,' specified by 'iter\&.' 
.RE
.PP

.SS "template<> constexpr const \fBbitMask\fP* ls::utils::getByte (const wchar_t *key, unsignediter)"

.PP
getByte (wchar_t string specialization) Retrieve the Nth byte of a basic data type\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP 
.br
\fIiter\fP The iterator which specifies the Nth byte in 'key'\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The Nth byte in 'key,' specified by 'iter\&.' 
.RE
.PP

.SS "template<> constexpr const \fBbitMask\fP* ls::utils::getByte (const char16_t *key, unsignediter)"

.PP
getByte (char16_t string specialization) Retrieve the Nth byte of a basic data type\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP 
.br
\fIiter\fP The iterator which specifies the Nth byte in 'key'\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The Nth byte in 'key,' specified by 'iter\&.' 
.RE
.PP

.SS "template<> constexpr const \fBbitMask\fP* ls::utils::getByte (const char32_t *key, unsignediter)"

.PP
getByte (char32_t string specialization) Retrieve the Nth byte of a basic data type\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP 
.br
\fIiter\fP The iterator which specifies the Nth byte in 'key'\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The Nth byte in 'key,' specified by 'iter\&.' 
.RE
.PP

.SS "template<typename\&.\&.\&. integral_t> constexpr unsigned ls::utils::getByteSize ()"

.PP
getByteSize Sum the number of bytes used by a set of types\&. 
.PP
\fBReturns:\fP
.RS 4
An unsigned integer, representing the size, in bytes, of a set of object types\&. These types can be built-in, or user-defined structures\&. 
.RE
.PP

.PP
Definition at line 24 of file byteSize_impl\&.h\&.
.SS "constexpr \fBendian_t\fP ls::utils::getEndianOrder ()"
A simple function that can be used to help determine a program's endianness at compile-time\&. 
.PP
Definition at line 38 of file endian\&.h\&.
.SS "constexpr \fBhash_t\fP ls::utils::hashCRC32 (const char *str, hash_tprevCrc = \fC0xFFFFFFFF\fP)"

.PP
CRC32 Hashing function A simple compile-time hashing function using the CRC32 algorithm\&. This method was adapted from a previous implementation on StackOverflow: http://stackoverflow.com/a/23683218/1217127
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP A c-style string that will be hashed\&.
.br
\fIprevCrc\fP A previous hash value that will be modified by the current string's hash\&.
.RE
.PP
\fBReturns:\fP
.RS 4
a 32-bit integer, representing a hashed value of the input string\&. 
.RE
.PP

.SS "constexpr \fBhash_t\fP ls::utils::hashDJB2 (const char *str)"

.PP
DJB2 Hashing Function This hash algorithm was found on here: http://nguillemot.blogspot.com/2012/06/side-story-compile-time-string-hashing.html\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP A pointer to a null-terminated c-style string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
an integer-type, representing the hash value using the DJB2 algorithm\&. 
.RE
.PP

.PP
Definition at line 19 of file hash_impl\&.h\&.
.SS "constexpr \fBhash_t\fP ls::utils::hashDJB2_impl (const char *str, unsigned inthashVal)"

.PP
Definition at line 9 of file hash_impl\&.h\&.
.SS "constexpr \fBhash_t\fP ls::utils::hashFNV1 (const char *str)"

.PP
FNV-1a Hashing Function This hash algorithm was found here: http://www.eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP A pointer to a null-terminated c-style string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
an integer-type, representing the hash value using the FNV-1a algorithm\&. 
.RE
.PP

.PP
Definition at line 59 of file hash_impl\&.h\&.
.SS "constexpr \fBhash_t\fP ls::utils::hashFNV1_impl (const char *str, unsigned inthashVal)"

.PP
Definition at line 49 of file hash_impl\&.h\&.
.SS "constexpr \fBhash_t\fP ls::utils::hashSDBM (const char *str)"

.PP
SDBM Hashing Function This hash algorithm was found here: http://www.cse.yorku.ca/~oz/hash.html\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP A pointer to a null-terminated c-style string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
an integer-type, representing the hash value using the SDBM algorithm\&. 
.RE
.PP

.PP
Definition at line 39 of file hash_impl\&.h\&.
.SS "constexpr \fBhash_t\fP ls::utils::hashSDBM_impl (const char *str, unsigned inthashVal)"

.PP
Definition at line 29 of file hash_impl\&.h\&.
.SS "template<typename Arg > void ls::utils::logErr (const Arg &arg)\fC [inline]\fP"

.PP
Definition at line 18 of file log_impl\&.h\&.
.SS "template<typename Arg , typename\&.\&.\&. Args> void ls::utils::logErr (const Arg &arg, const Args &\&.\&.\&.args)\fC [inline]\fP"

.PP
Definition at line 24 of file log_impl\&.h\&.
.SS "template<typename arg_t > void ls::utils::logErr (const arg_t &arg)\fC [inline]\fP"

.PP
Print multiple parameters to std::cerr\&. This method is syntactic sugar to write data to a standard output stream\&. It is similar to the printf() family of functions, however all values are separated by commas\&. Use of this function will cause a new line to be printed to the output stream afterwards; std::cerr\&.flush() will also be called\&.
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP A constant reference to a data type which can be send to std::cerr using the 'std::ostream::operator::<<()' overload\&. 
.RE
.PP

.SS "template<typename arg_t , typename\&.\&.\&. args_t> void ls::utils::logErr (const arg_t &arg, const args_t &\&.\&.\&.args)\fC [inline]\fP"

.PP
Print multiple parameters to std::cerr\&. This method is syntactic sugar to write data to a standard output stream\&. It is similar to the printf() family of functions, however all values are separated by commas\&. Use of this function will cause a new line to be printed to the output stream afterwards; std::cerr\&.flush() will also be called\&.
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP A constant reference to a data type which can be send to std::cerr using the 'std::ostream::operator::<<()' overload\&.
.br
\fIargs\fP A constant reference to multiple variadic arguments that will be written to std::cerr after 'arg' is written\&. 
.RE
.PP

.SS "template<typename Arg > void ls::utils::logMsg (const Arg &arg)\fC [inline]\fP"

.PP
Definition at line 6 of file log_impl\&.h\&.
.SS "template<typename Arg , typename\&.\&.\&. Args> void ls::utils::logMsg (const Arg &arg, const Args &\&.\&.\&.args)\fC [inline]\fP"

.PP
Definition at line 12 of file log_impl\&.h\&.
.SS "template<typename arg_t > void ls::utils::logMsg (const arg_t &arg)\fC [inline]\fP"

.PP
Print multiple parameters to std::cout\&. This method is syntactic sugar to write data to a standard output stream\&. It is similar to the printf() family of functions, however all values are separated by commas\&. Use of this function will cause a new line to be printed to the output stream afterwards; std::cout\&.flush() will also be called\&.
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP A constant reference to a data type which can be send to std::cout using the 'std::ostream::operator::<<()' overload\&. 
.RE
.PP

.SS "template<typename arg_t , typename\&.\&.\&. args_t> void ls::utils::logMsg (const arg_t &arg, const args_t &\&.\&.\&.args)\fC [inline]\fP"

.PP
Print multiple parameters to std::cout\&. This method is syntactic sugar to write data to a standard output stream\&. It is similar to the printf() family of functions, however all values are separated by commas\&. Use of this function will cause a new line to be printed to the output stream afterwards; std::cout\&.flush() will also be called\&.
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP A constant reference to a data type which can be send to std::cout using the 'std::ostream::operator::<<()' overload\&.
.br
\fIargs\fP A constant reference to multiple variadic arguments that will be written to std::cout after 'arg' is written\&. 
.RE
.PP

.SS "void ls::utils::runtime_assert (boolcondition, error_ttype, const char *constmsg)"

.PP
runtime_assert Throw an \fBls::utils::error_t\fP and/or send a message to stdout/stderr\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcondition\fP The boolean check to determine if an assertion should be raised\&. If the condition tests TRUE, then no assertion is made, otherwise an exception could be raised (of type \fBls::utils::error_t\fP), a message could be printed to stdout, or an error will be sent to stderr\&.
.br
\fItype\fP An error type that indicates if an assertion is a simple alert message, a warning, or a critical error\&.
.br
\fImsg\fP The message that will be printed to an standard output stream if the condition tests FALSE\&. 
.RE
.PP

.PP
Definition at line 8 of file assert\&.cpp\&.
.SS "template<typename T > std::string ls::utils::toString (const T &data)"

.PP
Convert a basic data type to an std::string\&. This function is only here because not all C++11-supporting versions of GCC have std::to_string()\&.
.PP
\fBParameters:\fP
.RS 4
\fIT\fP A generic type that can be printed to an std::ostream using the '<<' operator\&.
.RE
.PP
\fBReturns:\fP
.RS 4
std::string A string-representation of the input parameter 
.RE
.PP

.PP
Definition at line 8 of file string_utils_impl\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LightSky from the source code\&.
